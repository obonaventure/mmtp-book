
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Multipath TCP &#8212; Modern Multipath Transport Protocols 2022 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="_static/plot_directive.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Multipath QUIC" href="mpquic.html" />
    <link rel="prev" title="Principles of multipath transport" href="principles.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="multipath-tcp">
<h1>Multipath TCP<a class="headerlink" href="#multipath-tcp" title="Permalink to this headline">¶</a></h1>
<p>Multipath TCP <span id="id1">[<a class="reference internal" href="biblio.html#id8500" title="A. Ford, C. Raiciu, M. Handley, O. Bonaventure, and C. Paasch. TCP Extensions for Multipath Operation with Multiple Addresses. RFC 8684 (Proposed Standard), March 2020. URL: https://www.rfc-editor.org/rfc/rfc8684.txt, doi:10.17487/RFC8684.">49</a>]</span> is an extension to the TCP protocol <span id="id2">[<a class="reference internal" href="biblio.html#id729" title="J. Postel. Transmission Control Protocol. RFC 793 (Internet Standard), September 1981. Updated by RFCs 1122, 3168, 6093, 6528. URL: https://www.rfc-editor.org/rfc/rfc793.txt, doi:10.17487/RFC0793.">5</a>]</span> that was presented earlier. We start with an overview of Multipath TCP. Then we explain how a Multipath TCP connection can be established. Then we analyze how data is exchanged over different paths and explain the multipath congestion control schemes. Finally, we explain how Multipath TCP connections can be terminated.</p>
<div class="section" id="a-brief-overview-of-multipath-tcp">
<span id="mptcp-overview"></span><h2>A brief overview of Multipath TCP<a class="headerlink" href="#a-brief-overview-of-multipath-tcp" title="Permalink to this headline">¶</a></h2>
<p>The main design objective for Multipath TCP <span id="id3">[<a class="reference internal" href="biblio.html#id6658" title="A. Ford, C. Raiciu, M. Handley, and O. Bonaventure. TCP Extensions for Multipath Operation with Multiple Addresses. RFC 6824 (Experimental), January 2013. Obsoleted by RFC 8684. URL: https://www.rfc-editor.org/rfc/rfc6824.txt, doi:10.17487/RFC6824.">9</a>]</span> was to enable hosts to exchange the packets that belong to a single TCP connection over different network paths. Several definitions are possible for a network path. Considering a TCP connection between a client and a server, a network path can be defined as the succession of the links and routers that create a path between the client and the server. For example, in <a class="reference internal" href="#fig-simple-network"><span class="std std-numref">Fig. 34</span></a>, there are many paths between the client host <cite>C</cite> and the server <cite>S</cite>, e.g. <span class="math notranslate nohighlight">\(C \rightarrow R1 \rightarrow R2 \rightarrow R4 \rightarrow S\)</span> and <span class="math notranslate nohighlight">\(C \rightarrow R1 \rightarrow R3 \rightarrow R4 \rightarrow S\)</span>, but also <span class="math notranslate nohighlight">\(C \rightarrow R1 \rightarrow R3 \rightarrow R5 \rightarrow R4 \rightarrow S\)</span> or even <span class="math notranslate nohighlight">\(C \rightarrow R1 \rightarrow R2 \rightarrow R4 \rightarrow R3 \rightarrow R5 \rightarrow R4 \rightarrow S\)</span>.</p>
<div class="figure" id="id51" style="text-align: center">
<span id="fig-simple-network"></span><p><img  src="_images/tikz-69cb31f9853e78a5897d722ea8f00f15fa55fe26.png" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 34 </span><span class="caption-text">A simple network</span></p>
</div><p>During the first discussions on Multipath TCP within the IETF, there was a debate on the types of paths that Multipath TCP could use in IP networks. Although networks provide a wide range of paths between a source and a destination, it is not necessarily simple to use all these paths in a pure IP network. Looking a <a class="reference internal" href="#fig-simple-network"><span class="std std-numref">Fig. 34</span></a> and assuming that all links have the same IGP weigth, packets sent by <cite>C</cite> will follow one of the two shortest paths, i.e. <span class="math notranslate nohighlight">\(C \rightarrow R1 \rightarrow R2 \rightarrow R4 \rightarrow S\)</span> or <span class="math notranslate nohighlight">\(C \rightarrow R1 \rightarrow R3 \rightarrow R4 \rightarrow S\)</span>. Since routers usually use hash-hased load-balancing <span id="id4">[<a class="reference internal" href="biblio.html#id2922" title="C. Hopps. Analysis of an Equal-Cost Multi-Path Algorithm. RFC 2992 (Informational), November 2000. URL: https://www.rfc-editor.org/rfc/rfc2992.txt, doi:10.17487/RFC2992.">12</a>]</span> to distribute packets over equal cost paths, all the packets from a given connection will follow either the first or the second shortest path. In most networks, the path followed by a TCP connection will only change if there are link or router failures on this particular path.</p>
<p>When Multipath TCP was designed, the IETF did not want to design techniques to enable the transport layer to specify the paths that packets should follow. They opted for a very conservative definition of the paths that Multipath TCP can use <span id="id5">[<a class="reference internal" href="biblio.html#id6033" title="A. Ford, C. Raiciu, M. Handley, S. Barre, and J. Iyengar. Architectural Guidelines for Multipath TCP Development. RFC 6182 (Informational), March 2011. URL: https://www.rfc-editor.org/rfc/rfc6182.txt, doi:10.17487/RFC6182.">50</a>]</span>. Multipath TCP assumes that the endpoints of a TCP connection are identified by their IP addresses. If two hosts want to exchange packets over different paths, then at least one of them must have two or more IP addresses. This covers two very important use cases:</p>
<blockquote>
<div><ul class="simple">
<li><p>mobile devices like the smartphones that have a cellular and a Wi-Fi network interface each identified by its own IP address</p></li>
<li><p>dual-stack hosts that have both an IPv4 and an IPv6 address</p></li>
</ul>
</div></blockquote>
<p>In this document, we will often use smartphones to illustrate Multipath TCP client hosts. This corresponds to a widely deployed use case that simplifies many of the examples, but is not the only possible deployment.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Using non-equal cost paths with Multipath TCP</p>
<p>When Multipath TCP was designed, there was no standardized solution that enabled a host to control the path followed by its packets inside a network. This is slowly changing. First, the IETF has adopted the Segment Routing architecture <span id="id6">[<a class="reference internal" href="biblio.html#id8227" title="C. Filsfils (Ed.), S. Previdi (Ed.), L. Ginsberg, B. Decraene, S. Litkowski, and R. Shakir. Segment Routing Architecture. RFC 8402 (Proposed Standard), July 2018. URL: https://www.rfc-editor.org/rfc/rfc8402.txt, doi:10.17487/RFC8402.">51</a>]</span>. This architecture is a modern version of source routing which can be used in MPLS and IPv6 networks. In particular, using the IPv6 Segment Routing Header <span id="id7">[<a class="reference internal" href="biblio.html#id8570" title="C. Filsfils (Ed.), D. Dukes (Ed.), S. Previdi, J. Leddy, S. Matsushima, and D. Voyer. IPv6 Segment Routing Header (SRH). RFC 8754 (Proposed Standard), March 2020. URL: https://www.rfc-editor.org/rfc/rfc8754.txt, doi:10.17487/RFC8754.">52</a>]</span>, a host can decide the path that its packets will follow inside the network. This opens new possibilities for Multipath TCP. Some of these possibilities are explored by the Path Aware Networking Research Group of the Internet Research Task Force.</p>
</div>
<p>A second important design question for the Multipath TCP designers was how use two or more paths for a single connection ? As an example, let us consider a smartphone that interacts with a server. This smartphone has two different IP addresses: one over its Wi-Fi interface and one over its cellular interface. Assume that the smartphone initiates a TCP connection over its Wi-Fi interface. This handhsake is illustrated in blue in <a class="reference internal" href="#fig-mptcp-naive"><span class="std std-numref">Fig. 35</span></a>. It sends a data packet over this interface and the next one over the cellular one (shown in red).</p>
<div class="figure" id="id52" style="text-align: center">
<span id="fig-mptcp-naive"></span><p><img  src="_images/tikz-32002e044877a88681f2cded9bc04e6c2237dcad.png" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 35 </span><span class="caption-text">A naive approach to create a Multipath TCP connection</span></p>
</div><p>This utilization of the two paths between the smartphone and the server pose two different problems. First, the server must be able to accept the packet sent by the smarphone, that uses another source IP address than the address used during the handshake and associate it with an existing Multipath TCP connection. If the server blindingly accept this packet from another address than the one used during the handshake, then there are two main security risks. An attacker could inject a packet inside an existing connection. Furthermore, he could cause a denial of service attack by sending a spoofed packet in an existing connection that requests the server to send a large volume of data to the spoofed address. Second, a middlebox such as a firewall on the cellular path between the smartphone and the server could block the packet because it does not belong to a TCP connection created on the cellular path.</p>
<p>To cope with this problem, the Multipath TCP designers opted for an architecture where a Multipath TCP connection combines several TCP connections that are called subflows over the different paths. A Multipath TCP connection starts with a three-way handshake like a regular TCP connection. A client that wishes to use Multipath TCP sends a <code class="docutils literal notranslate"><span class="pre">SYN</span></code> with the <code class="docutils literal notranslate"><span class="pre">MP_CAPABLE</span></code> option to negotiate a Multipath TCP connection with a server. If the server replies with the same option, the handshake succeeds and creates the first subflow belonging to this Multipath TCP connection. The client and the server can send data over this connection as over any TCP connection. To use a second path, the client (or the server), must initiate another TCP handshake over the new path. The <code class="docutils literal notranslate"><span class="pre">SYN</span></code> sent over this second path uses the <code class="docutils literal notranslate"><span class="pre">MP_JOIN</span></code> option to indicate that this is an additional subflow that must be linked to an existing Multipath TCP connection. This is illustrated in <a class="reference internal" href="#fig-mptcp-capable-join"><span class="std std-numref">Fig. 36</span></a>.</p>
<div class="figure" id="id53" style="text-align: center">
<span id="fig-mptcp-capable-join"></span><p><img  src="_images/tikz-62ce6915297847743faec678d526c8bc965d321d.png" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 36 </span><span class="caption-text">A Multipath TCP connection with two subflows</span></p>
</div><p>These two three-way handshakes create two TCP connections called subflows in the Multipath TCP terminology. It is interesting to analyze how these two connections are identified on the server. A host identifies a TCP connection using four identifiers that are present in all the packets of this connection:</p>
<blockquote>
<div><ul class="simple">
<li><p>the local IP address</p></li>
<li><p>the remote IP address</p></li>
<li><p>the local port</p></li>
<li><p>the remote port</p></li>
</ul>
</div></blockquote>
<p>Assume that the client uses IP address <span class="math notranslate nohighlight">\(IP_{\alpha}\)</span> on its Wi-Fi intefance and <span class="math notranslate nohighlight">\(IP_{\beta}\)</span> on its cellular interface and that <span class="math notranslate nohighlight">\(p\)</span> is the port used by the server. If the client used port <span class="math notranslate nohighlight">\(p_1\)</span> to create the initial subflows, then the identifier of this subflow on the server is <span class="math notranslate nohighlight">\(&lt;IP_{S},IP_{\alpha},p,p_{1}&gt;\)</span>. Similarly, the second subflow is identified by the <span class="math notranslate nohighlight">\(&lt;IP_{S},IP_{\beta},p,p_{2}&gt;\)</span> tuple on the server. Note that these two connection identifiers differ by at least one IP address as specified in <span id="id8">[<a class="reference internal" href="biblio.html#id6033" title="A. Ford, C. Raiciu, M. Handley, S. Barre, and J. Iyengar. Architectural Guidelines for Multipath TCP Development. RFC 6182 (Informational), March 2011. URL: https://www.rfc-editor.org/rfc/rfc6182.txt, doi:10.17487/RFC6182.">50</a>]</span>.</p>
<p>A server usually manages a large number of simulatenous connections. When it receives the <code class="docutils literal notranslate"><span class="pre">SYN</span></code> for the second subflow, it must be able to link this new subflow with the corresponding Multipath TCP connection. For this, the client must include an identifier of associated Multipath TCP connection in its <code class="docutils literal notranslate"><span class="pre">MP_JOIN</span></code> option. This identifier must unambiguously identify the corresponding Multipath TCP connection on the server.</p>
<p>A first possible identifier is the four tuple that identifies the initial subflow, i.e. <span class="math notranslate nohighlight">\(&lt;IP_{S},IP_{\alpha},p,p_{1}&gt;\)</span>. If the server received this identifier in the <code class="docutils literal notranslate"><span class="pre">MP_JOIN</span></code> option, it could link the new subflow to the previous one. Unfortunately, this solution does not work in today’s Internet. The main concern comes from the middleboxes such as NATs and transparent proxies. To illustrate the problem, consider a simple NAT, such as the one used on most home Wi-Fi access points. <a class="reference internal" href="#fig-nat-interference"><span class="std std-numref">Fig. 37</span></a> illustrates a handshake in such an evnrionment. If we assume that the NAT only changes the client’s IP address, then the connection is identified by the <span class="math notranslate nohighlight">\(&lt;IP_{A},IP_{S},p,p_{1}&gt;\)</span> tuple on the smartphone and <span class="math notranslate nohighlight">\(&lt;IP_{S},IP_{N},p,p_{1}&gt;\)</span> on the server. Note that a NAT could also change the client port. If the smartphone places its local connection identifier inside an <code class="docutils literal notranslate"><span class="pre">MP_JOIN</span></code> option, the server might not be able to recognise the corresponding connection in the <code class="docutils literal notranslate"><span class="pre">SYN</span></code> packets that it received.</p>
<div class="figure" id="id54" style="text-align: center">
<span id="fig-nat-interference"></span><p><img  src="_images/tikz-fce585f814aa224e8ae25d053e89f79d7f279d9e.png" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 37 </span><span class="caption-text">With Network Address Translation, A naive approach to create a Multipath TCP connection</span></p>
</div><p>To cope with this problem, Multipath TCP uses a local identifier, called <cite>token</cite> in the Multipath TCP specification, to identify each Multipath TCP connection. The client assigns its token when it initiates a new Multipath TCP connection. A server assigns its token when it accepts a new Multipath TCP connection. These two tokens are chosen idependently by the client and the server. For security reasons, they should be random. The <code class="docutils literal notranslate"><span class="pre">MP_JOIN</span></code> option contains the token assigned by the remote host. This is illustrated in <a class="reference internal" href="#fig-mptcp-capable-join-token"><span class="std std-numref">Fig. 38</span></a>. The server assigns token <cite>456</cite> to the Multipath TCP connection created as the first subflow. It informs the smartphone by sending this token in its <code class="docutils literal notranslate"><span class="pre">MP_CAPABLE</span></code> option in the <code class="docutils literal notranslate"><span class="pre">SYN+ACK</span></code>. When the client creates the second subflow, it includes this token in the <code class="docutils literal notranslate"><span class="pre">MP_JOIN</span></code> option of its <code class="docutils literal notranslate"><span class="pre">SYN</span></code>.</p>
<div class="figure" id="id55" style="text-align: center">
<span id="fig-mptcp-capable-join-token"></span><p><img  src="_images/tikz-f09d81ff7621625391dd94cab406435ab16825f7.png" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 38 </span><span class="caption-text">A Multipath TCP connection with two subflows</span></p>
</div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Multipath TCP in datacenters</p>
<p>The Multipath TCP architecture <span id="id9">[<a class="reference internal" href="biblio.html#id6033" title="A. Ford, C. Raiciu, M. Handley, S. Barre, and J. Iyengar. Architectural Guidelines for Multipath TCP Development. RFC 6182 (Informational), March 2011. URL: https://www.rfc-editor.org/rfc/rfc6182.txt, doi:10.17487/RFC6182.">50</a>]</span> assumes that at least one of the communicating hosts will use different IP addresses to identify the different paths used by a Multipath TCP connection. In practice, this architectural requirement is not always enforced by Multipath TCP implementations. A Multipath TCP implementation can combine different subflows into one Multipath TCP connection provided that each subflow is identified by a different four-tuple. Two subflows between two communicating hosts can differ in their client-selected ports. This solution has been chosen when Multipath TCP was proposed to mitigate congestion in datacenter networks <span id="id10">[<a class="reference internal" href="biblio.html#id8923" title="C. Raiciu, S. Barre, C. Pluntke, A. Greenhalgh, D. Wischik, and M. Handley. Improving Datacenter Performance and Robustness with Multipath TCP. In ACM SIGCOMM 2011. 2011. URL: http://doi.acm.org/10.1145/2018436.2018467, doi:10.1145/2018436.2018467.">11</a>]</span>.</p>
<p>Several designs exist for datacenter networks, but the fat-tree architecture shown in <a class="reference internal" href="#fig-fat-tree"><span class="std std-numref">Fig. 39</span></a> is a very popular one.</p>
<div class="figure" id="id56" style="text-align: center">
<span id="fig-fat-tree"></span><p><img  src="_images/tikz-e1f997920097a756017085556d1cfbf46dc5708b.png" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 39 </span><span class="caption-text">A simple datacenter network</span></p>
</div><p>This network topology exposes a large number of equal cost paths between the servers that are shown using circles in <a class="reference internal" href="#fig-fat-tree"><span class="std std-numref">Fig. 39</span></a>. For example, consider the paths between the <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\pi\)</span> hosts. The paths start at <span class="math notranslate nohighlight">\(E1\)</span>. This router can reach <span class="math notranslate nohighlight">\(E4\)</span> and <span class="math notranslate nohighlight">\(\pi\)</span> via <span class="math notranslate nohighlight">\(A1\)</span> or <span class="math notranslate nohighlight">\(A2\)</span>. Each of these two aggregation routers can reach <span class="math notranslate nohighlight">\(\pi\)</span> via one of the two core routers. These two routers can then balance the flows via both <span class="math notranslate nohighlight">\(A3\)</span> and <span class="math notranslate nohighlight">\(A4\)</span>. There are <span class="math notranslate nohighlight">\(2^{4}=16\)</span> different paths between <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\pi\)</span> in this very small network. If each of these routers balance the incoming packets using a hash function that takes as input their source and destination addresses and ports, then the subflows of a Multipath TCP connection that use different client problems will be spread evenly accross the network topology.  Raiciu et al. provide simulations and measurements showing the benefits of using Multipath TCP in datacenters <span id="id11">[<a class="reference internal" href="biblio.html#id8923" title="C. Raiciu, S. Barre, C. Pluntke, A. Greenhalgh, D. Wischik, and M. Handley. Improving Datacenter Performance and Robustness with Multipath TCP. In ACM SIGCOMM 2011. 2011. URL: http://doi.acm.org/10.1145/2018436.2018467, doi:10.1145/2018436.2018467.">11</a>]</span>.</p>
</div>
<p>Once a Multipath TCP connection and the additional subflows have been established, we can use them to exchange data. An important point to remember is that a Multipath TCP connection offers a bidirectional bytestream service like a regular TCP connection. This service does not change even if Multipath TCP uses different subflows to carry the data between the sender and the receiver. As an example, consider a sender that sends <code class="docutils literal notranslate"><span class="pre">ABCD</span></code> one byte at a time over a Multipath TCP connection composed of two subflows. A naive approach to sedn these bytes would be to simply placed them in TCP segments. This is illustrated in <a class="reference internal" href="#fig-mptcp-data-naive"><span class="std std-numref">Fig. 40</span></a> where we assume that the two TCP subflows have already been established.</p>
<div class="figure" id="id57" style="text-align: center">
<span id="fig-mptcp-data-naive"></span><p><img  src="_images/tikz-891588383ff57dc5137de58cd0b155f610f30b59.png" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 40 </span><span class="caption-text">A naive approach to send data over a Multipath TCP connection</span></p>
</div><p>In this example, the Smartphone slowly sends data in sequence. The server receives the data in sequence over the two subflows and the server could simply deliver the data as soon as it arrives over each subflow. This is illustrated with the <code class="docutils literal notranslate"><span class="pre">DATA.ind(\ldots)</span></code> primitives that represent the delivery of the data to the server application. However, consider now that the first packet sent on the red subflow is lost and is retransmitted together with the fourth byte as shown in <a class="reference internal" href="#fig-mptcp-data-naive-2"><span class="std std-numref">Fig. 41</span></a>.</p>
<div class="figure" id="id58" style="text-align: center">
<span id="fig-mptcp-data-naive-2"></span><p><img  src="_images/tikz-4c883aad284995a0a986e808c1fe170585b864f8.png" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 41 </span><span class="caption-text">A naive approach to send data over a Multipath TCP connection</span></p>
</div><p>In <a class="reference internal" href="#fig-mptcp-data-naive-2"><span class="std std-numref">Fig. 41</span></a>, it is clear that the server cannot simply deliver the data as soon as it receives it to its application. If the server behaves this way, it will deliver <code class="docutils literal notranslate"><span class="pre">ACBD</span></code> to its application instead of the <code class="docutils literal notranslate"><span class="pre">ABCD</span></code> bytestream send by the smartphone. To cope with the reordering of the data sent over the different subflows, Multipath TCP includes bytestream-level data sequence numbers that enable it to preserve the ordering of the data sent over the bytestream. This is illustrated in <a class="reference internal" href="#fig-mptcp-data-seq"><span class="std std-numref">Fig. 42</span></a> with the bytestream-level sequence number shown as <code class="docutils literal notranslate"><span class="pre">bseq</span></code>. We will detail later how this sequence number is exactly transported by Multipath TCP.</p>
<div class="figure" id="id59" style="text-align: center">
<span id="fig-mptcp-data-seq"></span><p><img  src="_images/tikz-d1207bed27ab36957870a6215ddeb8597274381a.png" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 42 </span><span class="caption-text">A naive approach to send data over a Multipath TCP connection</span></p>
</div><p>Thanks to the bytestream sequence number, the server can reorder the data received over the different subflows and preserve the ordering in the bytestream.</p>
</div>
<div class="section" id="creating-a-multipath-tcp-connection">
<span id="mptcp-initial-handshake"></span><h2>Creating a Multipath TCP connection<a class="headerlink" href="#creating-a-multipath-tcp-connection" title="Permalink to this headline">¶</a></h2>
<p>Before delving into the details of how a Multipath TCP connection is created, let use first analyze the main requirements of this establishment and how they can be met without considering all the protocol details. During the three-way handshake, TCP hosts agree to establishment a connection, select the initial sequence number in each direction and negotiate the utilization of TCP extensions. In addition to these objectives, the handshake used by Multipath TCP also allows the communicating hosts to:</p>
<blockquote>
<div><ul class="simple">
<li><p>agree to use the Multipath TCP extension</p></li>
<li><p>exchange the tokens used to identify the connection</p></li>
<li><p>agree on initial bytestream sequence numbers</p></li>
</ul>
</div></blockquote>
<p>To meet the first objective, the client simply needs to send a Multipath TCP option (<code class="docutils literal notranslate"><span class="pre">MPO</span></code>) in its <code class="docutils literal notranslate"><span class="pre">SYN</span></code>. If the server supports Multipath TCP, it will respond with a <code class="docutils literal notranslate"><span class="pre">SYNC+AC</span></code> that carries this option.</p>
<p>To meet the second objective, the simplest solution is reserve some space, e.g. 64 bits, in the <code class="docutils literal notranslate"><span class="pre">MPO</span></code> option to encode the token chosen by the host that sends the <code class="docutils literal notranslate"><span class="pre">SYN</span></code> or <code class="docutils literal notranslate"><span class="pre">SYN+ACK</span></code>. With this approach, each host can autonomously select the token that it uses to identify each Multipath TCP connection. To meet the third objective, the simplest solution is also to place the initial sequence number in the <code class="docutils literal notranslate"><span class="pre">MPO</span></code> option. <a class="reference internal" href="#fig-tcp-handshake-mpo"><span class="std std-numref">Fig. 43</span></a> illustrates a handshake using the <code class="docutils literal notranslate"><span class="pre">MPO</span></code> option.</p>
<div class="figure" id="id60" style="text-align: center">
<span id="fig-tcp-handshake-mpo"></span><p><img  src="_images/tikz-d7be5554663095fff10c0eb8dd8cc97da02dc5e0.png" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 43 </span><span class="caption-text">Opening a Multipath TCP connection with a MPO option</span></p>
</div><p>The Multipath TCP working group was worried about the risk of attacks with this approach. When the smartphone creates an additional subflow, it includes the token allocated by the server inside the <code class="docutils literal notranslate"><span class="pre">MP_JOIN</span></code> option. This token serves two different purposes. First, it identifies the relevant Multipath TCP connection on the server. Second, it also “authenticates” that the <code class="docutils literal notranslate"><span class="pre">SYN</span></code> also originates from this client. Authenticating the client is a key concern from a security viewpoint. The main risk is that an on-path attacker who has observed the token in the <code class="docutils literal notranslate"><span class="pre">MP_JOIN</span></code> option can reuse it to create additional subflows from any other source. To cope with this problem, Multipath TCP relies on a shared secret that the client and the server exchange during the initial handshake. The client proposes one halve of the secret and the server the other halve. This is illustrated in <a class="reference internal" href="#fig-tcp-handshake-mpo-secret"><span class="std std-numref">Fig. 44</span></a>. The client proposes its part of the shared secret in the <code class="docutils literal notranslate"><span class="pre">SYN</span></code> (<span class="math notranslate nohighlight">\(Client_{secret}\)</span>). The server replies with its part of the secret in the <code class="docutils literal notranslate"><span class="pre">SYN+ACK</span></code>.</p>
<div class="figure" id="id61" style="text-align: center">
<span id="fig-tcp-handshake-mpo-secret"></span><p><img  src="_images/tikz-0672548dc4999a2cb5bc482ae61f5425b1e2fa13.png" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 44 </span><span class="caption-text">Creating a Multipath TCP connection with a MPO option</span></p>
</div><p>Using these two components of the shared secret, the client and the server must be able to authenticate the additional subflows without revealing the shared secret to an attacker who is able to capture packets on the path of the additional subflow. Multipath TCP requires each host to perform a HMAC <span id="id12">[<a class="reference internal" href="biblio.html#id2034" title="H. Krawczyk, M. Bellare, and R. Canetti. HMAC: Keyed-Hashing for Message Authentication. RFC 2104 (Informational), February 1997. Updated by RFC 6151. URL: https://www.rfc-editor.org/rfc/rfc2104.txt, doi:10.17487/RFC2104.">53</a>]</span> of a random number to confirm their knowledge of the shared secret. This is illustrated in the second part of <a class="reference internal" href="#fig-tcp-handshake-mpo-secret"><span class="std std-numref">Fig. 44</span></a>. To create the additional subflow, the client send a <code class="docutils literal notranslate"><span class="pre">SYN</span></code> with the <code class="docutils literal notranslate"><span class="pre">MP_JOIN</span></code> option containing the <span class="math notranslate nohighlight">\(Server_{token}\)</span> and a random nonce, <span class="math notranslate nohighlight">\(Client_{random}\)</span>. The server confirms the establishment of the subflow by sending a <code class="docutils literal notranslate"><span class="pre">SYN+ACK</span></code> containing the HMAC computed using the <span class="math notranslate nohighlight">\(Client_{random}\)</span> and the <span class="math notranslate nohighlight">\(Client_{secret}\)</span> and <span class="math notranslate nohighlight">\(Server_{secret}\)</span> input. Thanks to this HMAC computation, the server can reveal that it knows <span class="math notranslate nohighlight">\(Client_{secret}\)</span> and <span class="math notranslate nohighlight">\(Server_{secret}\)</span> without explictly sending them. The server also places a random number, <span class="math notranslate nohighlight">\(Server_{random}\)</span> in the <code class="docutils literal notranslate"><span class="pre">MP_JOIN</span></code> option of the <code class="docutils literal notranslate"><span class="pre">SYN+ACK</span></code>. The client computes a HMAC and returns it in the third <code class="docutils literal notranslate"><span class="pre">ACK</span></code>. With these two HMACs, the client and the server can authenticate the establishment of the additional subflow without revealing the shared secret.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The security of Multipath TCP depends on the security of the initial handshake</p>
<p>The ability of correctly authenticate the addition of new subflows to a Multipath TCP connection depends on the secrecy of the <span class="math notranslate nohighlight">\(Client_{secret}\)</span> and <span class="math notranslate nohighlight">\(Server_{secret}\)</span> exchanged in the <code class="docutils literal notranslate"><span class="pre">SYN</span></code> and <code class="docutils literal notranslate"><span class="pre">SYN+ACK</span></code> of the initial handshake. An on-path attacker which is able to capture this initial handshake has all the information required to attach a new subflow to this Multipath TCP connectionat any time. Multipath does not include the strong cryptographic techniques (besides HMAC) that would have been required to completely secure the establishment the protocol and the establishment of additional subflows in particular. This threat was considered acceptable for Multipath TCP <span id="id13">[<a class="reference internal" href="biblio.html#id6032" title="M. Bagnulo. Threat Analysis for TCP Extensions for Multipath Operation with Multiple Addresses. RFC 6181 (Informational), March 2011. URL: https://www.rfc-editor.org/rfc/rfc6181.txt, doi:10.17487/RFC6181.">54</a>]</span> because an attacker who can capture the packets of a single path TCP connection can also inject data inside this connection. To be fully secure Multipath TCP would need to rely on cryptographic techniques that are similar to those used in Transport Layer Security <span id="id14">[<a class="reference internal" href="biblio.html#id8271" title="E. Rescorla. The Transport Layer Security (TLS) Protocol Version 1.3. RFC 8446 (Proposed Standard), August 2018. URL: https://www.rfc-editor.org/rfc/rfc8446.txt, doi:10.17487/RFC8446.">6</a>]</span>.</p>
</div>
<p>The solution described above meets the requirements of the Internet Engineering Task Force. From a security viewpoint, the <span class="math notranslate nohighlight">\(Client_{secret}\)</span>, <span class="math notranslate nohighlight">\(Server_{secret}\)</span> and the random nonces should be as large as possible to prevent attacks where their values are simply guessed. Unfortunately, since Multipath TCP uses TCP options to exchange all this information, we need to ensure that it fits inside the extended header of a TCP <code class="docutils literal notranslate"><span class="pre">SYN</span></code>. The TCP specification <span id="id15">[<a class="reference internal" href="biblio.html#id729" title="J. Postel. Transmission Control Protocol. RFC 793 (Internet Standard), September 1981. Updated by RFCs 1122, 3168, 6093, 6528. URL: https://www.rfc-editor.org/rfc/rfc793.txt, doi:10.17487/RFC0793.">5</a>]</span> reserves up to 40 bytes to place the TCP options in a <code class="docutils literal notranslate"><span class="pre">SYN</span></code>. Today’s TCP stacks already consume 4 bytes for the <code class="docutils literal notranslate"><span class="pre">MSS</span></code> option <span id="id16">[<a class="reference internal" href="biblio.html#id729" title="J. Postel. Transmission Control Protocol. RFC 793 (Internet Standard), September 1981. Updated by RFCs 1122, 3168, 6093, 6528. URL: https://www.rfc-editor.org/rfc/rfc793.txt, doi:10.17487/RFC0793.">5</a>]</span>, 3 for the <code class="docutils literal notranslate"><span class="pre">Window</span> <span class="pre">Scale</span></code> option <span id="id17">[<a class="reference internal" href="biblio.html#id1255" title="V. Jacobson, R. Braden, and D. Borman. TCP Extensions for High Performance. RFC 1323 (Proposed Standard), May 1992. Obsoleted by RFC 7323. URL: https://www.rfc-editor.org/rfc/rfc1323.txt, doi:10.17487/RFC1323.">22</a>]</span>, 2 for <code class="docutils literal notranslate"><span class="pre">SACK</span> <span class="pre">Permitted</span></code> <span id="id18">[<a class="reference internal" href="biblio.html#id1948" title="M. Mathis, J. Mahdavi, S. Floyd, and A. Romanow. TCP Selective Acknowledgment Options. RFC 2018 (Proposed Standard), October 1996. URL: https://www.rfc-editor.org/rfc/rfc2018.txt, doi:10.17487/RFC2018.">13</a>]</span> and 10 for the timestamp option <span id="id19">[<a class="reference internal" href="biblio.html#id1255" title="V. Jacobson, R. Braden, and D. Borman. TCP Extensions for High Performance. RFC 1323 (Proposed Standard), May 1992. Obsoleted by RFC 7323. URL: https://www.rfc-editor.org/rfc/rfc1323.txt, doi:10.17487/RFC1323.">22</a>]</span>. This leaves only 20 bytes to encode a Multipath TCP option that must contain an initial sequence number, a token and a secret. Multipath TCP solves this problem by deriving these three values from a single field encoded in a TCP option. Let us now analyze the Multipath TCP handshake in more details.</p>
<div class="section" id="the-multipath-tcp-handshake">
<span id="mptcp-initial-mptcp-handshake"></span><h3>The Multipath TCP handshake<a class="headerlink" href="#the-multipath-tcp-handshake" title="Permalink to this headline">¶</a></h3>
<p>A Multipath TCP connection starts with a three-way handshake like a regular TCP connection. To indicate that it wishes to use Multipath TCP, the client adds the <code class="docutils literal notranslate"><span class="pre">MP_CAPABLE</span></code> option to the <code class="docutils literal notranslate"><span class="pre">SYN</span></code> segment. In the <code class="docutils literal notranslate"><span class="pre">SYN</span></code> segment, this option only contains some flags and occupies 4 bytes. The server replies with a <code class="docutils literal notranslate"><span class="pre">SYN+ACK</span></code> segment than contains an <code class="docutils literal notranslate"><span class="pre">MP_CAPABLE</span></code> option including a server generated 64 bits random key that will be used to authenticate connections over different paths. The client concludes the handshake by sending an <code class="docutils literal notranslate"><span class="pre">MP_CAPABLE</span></code> option in the <code class="docutils literal notranslate"><span class="pre">ACK</span></code> segment containing the random keys chosen by the client and the server.</p>
<div class="figure" id="id62" style="text-align: center">
<span id="fig-tcp-handshake-mptcp"></span><p><img  src="_images/tikz-ed25d0038ac945d925180e09e319ecdb136f1235.png" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 45 </span><span class="caption-text">Negotiating the utilization of Multipath TCP during the three-way handshake</span></p>
</div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Multipath TCP version 0</p>
<p>The first version of Multipath TCP used a slightly different handshake <span id="id20">[<a class="reference internal" href="biblio.html#id6658" title="A. Ford, C. Raiciu, M. Handley, and O. Bonaventure. TCP Extensions for Multipath Operation with Multiple Addresses. RFC 6824 (Experimental), January 2013. Obsoleted by RFC 8684. URL: https://www.rfc-editor.org/rfc/rfc6824.txt, doi:10.17487/RFC6824.">9</a>]</span>. The <code class="docutils literal notranslate"><span class="pre">MP_CAPABLE</span></code> option sent by the client contains the 64 bits key chosen by the client. The <code class="docutils literal notranslate"><span class="pre">SYN+ACK</span></code> segment contains an <code class="docutils literal notranslate"><span class="pre">MP_CAPABLE</span></code> option with 64 bits key chosen by the server. The client echoes the client and server keys in the third <code class="docutils literal notranslate"><span class="pre">ACK</span></code> of the handshake.</p>
<div class="figure" id="id63" style="text-align: center">
<span id="fig-tcp-handshake-mptcp-v0"></span><p><img  src="_images/tikz-effce21be436f752e54a38a0752aecbb5928709b.png" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 46 </span><span class="caption-text">Negotiating the utilization of Multipath TCP version 0</span></p>
</div></div>
<p>The 64 bits random keys chosen by the client and the server play three different roles in Multipath TCP. Their first role is to identify the Multipath TCP connection to which an additional connection must be attached. Since a Multipath TCP connection can combine several TCP connections, Multipath TCP cannot use the IP addresses and port numbers to identify a TCP connection. Multipath TCP uses a specific identifier that is called a token. For technical reasons, this token is derived from the 64 bits key as the most significant 32 bits of the SHA-256 <span id="id21">[<a class="reference internal" href="biblio.html#id6083" title="D. Eastlake 3rd and T. Hansen. US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF). RFC 6234 (Informational), May 2011. URL: https://www.rfc-editor.org/rfc/rfc6234.txt, doi:10.17487/RFC6234.">55</a>]</span> hash of the key. The second role of the 64 bits keys is to authenticate the establishment of additional connections as we will see shortly. Finally, the keys are also used to compute random initial sequence numbers.</p>
<p>The main benefit of Multipath TCP is that a Multipath TCP connection can combine different TCP connections that potentially use different paths. Starting from now on, we will consider a client with two network interfaces and a server with one network interface. This could for example correspond to a client application running on a smartphone that interacts with a server. We explore more complex scenarios later.</p>
<p>We can know explain how a Multipath TCP connection can combine different TCP connections. According to the Multipath TCP specification, these connections are called subflows <span id="id22">[<a class="reference internal" href="biblio.html#id8500" title="A. Ford, C. Raiciu, M. Handley, O. Bonaventure, and C. Paasch. TCP Extensions for Multipath Operation with Multiple Addresses. RFC 8684 (Proposed Standard), March 2020. URL: https://www.rfc-editor.org/rfc/rfc8684.txt, doi:10.17487/RFC8684.">49</a>]</span>. We also adopt this terminology in this document. <a class="reference internal" href="#fig-mptcp-join"><span class="std std-numref">Fig. 47</span></a> shows a Multipath TCP that combines two subflows. To establish the Multipath TCP connection, the client initiates the initial subflow by using the <code class="docutils literal notranslate"><span class="pre">MP_CAPABLE</span></code> option during the three-way handshake. At the end of the initial handshake, the client and the server have exchanged their keys. Based on their keys, they have both computed the token that the remote host uses to identify the Multipath TCP connection.</p>
<p>To attach a second subflow to this Multipath TCP connection, the client needs to create it. For this, it starts a three-way handshake with the server by sending a <code class="docutils literal notranslate"><span class="pre">SYN</span></code> segment containing the <code class="docutils literal notranslate"><span class="pre">MP_JOIN</span></code> option. This option indicates that the client uses Multipath TCP and wishes to attach this new connection to an existing Multipath TCP connection. The <code class="docutils literal notranslate"><span class="pre">MP_JOIN</span></code> option contains two important fields:</p>
<blockquote>
<div><ul class="simple">
<li><p>the token that the server uses to identify the Multipath TCP connection</p></li>
<li><p>a random nonce</p></li>
</ul>
</div></blockquote>
<p>The client has derived the token from the key announced by the server in the <code class="docutils literal notranslate"><span class="pre">MP_CAPABLE</span></code> option of the <code class="docutils literal notranslate"><span class="pre">SYN+ACK</span></code> segment on the initial subflow. Thanks to this token, the server knows to which Multipath TCP connection the new subflow needs to be attached.</p>
<div class="admonition-todo admonition" id="id23">
<p class="admonition-title">Todo</p>
<p>discuss security concerns</p>
</div>
<p>The server uses the random nonce sent by the client and its own random nonce to prove its knowledge of the keys exchanged during the initial handshake. The server computes <span class="math notranslate nohighlight">\(HMAC(Key=(Server_{key}||Client_{key}), Msg=(nonce_{Server}||nonce_{Client}))\)</span>, where <code class="docutils literal notranslate"><span class="pre">||</span></code> denotes the concatenation operation. It then returns the high order 64 bits of this HMAC in the <code class="docutils literal notranslate"><span class="pre">MP_JOIN</span></code> option of the <code class="docutils literal notranslate"><span class="pre">SYN+ACK</span></code> segment together with its 32 bits nonce. The client computes <span class="math notranslate nohighlight">\(HMAC(Key=(Client_{key}||Server_{key}), Msg=(nonce_{Client}||nonce_{Server}))\)</span> and sends the 160 bits HMAC in the <code class="docutils literal notranslate"><span class="pre">ACK</span></code> segment.</p>
<div class="figure" id="id64" style="text-align: center">
<span id="fig-mptcp-join"></span><p><img  src="_images/tikz-eefcb7d64afe220501f146912b9992a9f23ee8fd.png" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 47 </span><span class="caption-text">A client creates a second subflow by creating a TCP connection with the <code class="docutils literal notranslate"><span class="pre">MP_JOIN</span></code> option</span></p>
</div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Generating Multipath TCP keys</p>
<p>From a security viewpoint, the keys that Multipath TCP hosts exchange in the <code class="docutils literal notranslate"><span class="pre">MP_CAPABLE</span></code> option should be completely random to prevent them from being guessed by attackers. However, since the token is derived from the key, it cannot be completely random. A host will typically generate a random key and hash it into a token to verify that it does not correspond to an existing connection. On clients, with a few tens of connections, this is not a concern, but on servers, the delay to generate random keys increases with the number of established Multipath TCP connections <span id="id24">[<a class="reference internal" href="biblio.html#id8931" title="Costin Raiciu, Christoph Paasch, Sebastien Barre, Alan Ford, Michio Honda, Fabien Duchene, Olivier Bonaventure, and Mark Handley. How hard can it be? Designing and implementing a deployable Multipath TCP. In Proceedings of the 9th USENIX Conference on Networked Systems Design and Implementation, NSDI'12, 29–29. Berkeley, CA, USA, 2012. USENIX Association. URL: http://inl.info.ucl.ac.be/publications/how-hard-can-it-be-designing-and-implementing-deployable-multipath-tcp.">56</a>]</span>. This does not prevent servers from supporting large numbers of Multipath TCP connections <span id="id25">[<a class="reference internal" href="biblio.html#id8991" title="Nicolas Keukeleire, Benjamin Hesmans, and Olivier Bonaventure. Increasing broadband reach with hybrid access networks. IEEE Communications Standards Magazine, 4(1):43–49, 2020.">57</a>]</span>.</p>
</div>
<p>A Multipath TCP connection combines a number of subflows which can change during the connection lifetime. It starts with an initial subflow, but this subflow may terminate before the connection. A Multipath TCP connection is a pair of states that are maintained on the client and the server.</p>
<p>The above figure shows how a client adds a subflow to an existing Multipath TCP connection. This is the most common way of adding subflows to a connection. According to the specification, a server could also add subflows to a Multipath TCP connection. For this, the server needs to be able to determine the client addresses. This is the role of the address subflow management parts of Multipath TCP.</p>
</div>
</div>
<div class="section" id="address-and-subflow-management">
<span id="mptcp-addr-management"></span><h2>Address and subflow management<a class="headerlink" href="#address-and-subflow-management" title="Permalink to this headline">¶</a></h2>
<p>Each Internet host has one address per network interface. A smartphone with active Wi-Fi and cellular interfaces has two network addresses. With the advent of IPv6, a large fraction of the hosts are dual-stack and have both an IPv4 and an IPv6 address for each network interface. Multipath TCP specifies options that allow a host to advertise all its addresses to the other host. Given the limited size of the TCP header, these options cannot be exchanged during the handshake. They are typically attached to packets that carry acknowledgements.</p>
<p>Each host maintains a list of its active addresses and associates a numeric identifier to each address. To advertise an address, the host simple adds the Multipath TCP <code class="docutils literal notranslate"><span class="pre">ADD_ADDR</span></code> option to one outgoing packet. This option contains four main fields:</p>
<blockquote>
<div><ul class="simple">
<li><p>the IPv4 or IPv6 address of the host</p></li>
<li><p>the numeric identifier of the address</p></li>
<li><p>an optionnal port number</p></li>
<li><p>a truncated HMAC to authenticate the address advertisement</p></li>
</ul>
</div></blockquote>
<p>The IP address is the main information contained in the <code class="docutils literal notranslate"><span class="pre">ADD_ADDR</span></code> option. The identifier allows the host to advertise the list of all its addresses one option at a time. The port number allows to indicate that the hosts listens to another port number than the one used for the subflow where the option is sent. This can be useful if a client wishes to accept subflows initiated by the server or if a server uses another port to listen for additional subflows. The HMAC is the 64 truncatenation of <span class="math notranslate nohighlight">\(HMAC(Key=(Server_{key}||Client_{key}), Msg=(Address identifier||IP address|| port))\)</span> when the server advertises an address and <span class="math notranslate nohighlight">\(HMAC(Key=(Client_{key}||Server_{key}), Msg=(Address identifier||IP address|| port))\)</span> for an address advertised by the client. The HMAC allows to prevent attacks where an attacker sends spoofed packets containing an <code class="docutils literal notranslate"><span class="pre">ADD_ADDR</span></code> option.</p>
<p>In addition to these four fields, the <code class="docutils literal notranslate"><span class="pre">ADD_ADDR</span></code> option contains an <code class="docutils literal notranslate"><span class="pre">Echo</span></code> bit. The <code class="docutils literal notranslate"><span class="pre">ADD_ADDR</span></code> option is usually sent inside a TCP acknowledgement. A host can easily send an acknowledgement even if it did not recently receive data. Unfortunately, TCP acknowledgements are, by design, unreliable. As TCP uses cumulative acknowledgements, the loss of an acknowledgement is compensated by the next acknowledgement. This is true for the acknowledgement number, but not for the options that were contained in the loss packet. The first version of Multipath TCP did not try to deal with the loss of <code class="docutils literal notranslate"><span class="pre">ADD_ADDR</span></code> options. The current version relies on the <code class="docutils literal notranslate"><span class="pre">Echo</span></code>. A host advertises an address by sending its <code class="docutils literal notranslate"><span class="pre">ADD_ADDR</span></code> option with the <code class="docutils literal notranslate"><span class="pre">Echo</span></code> bit set to <code class="docutils literal notranslate"><span class="pre">0</span></code>. To confirm the reception of this address, the peer simply replies with an acknowledgement containing the same option but with its <code class="docutils literal notranslate"><span class="pre">Echo</span></code> bit set to one. A host that sent an <code class="docutils literal notranslate"><span class="pre">ADD_ADDR</span></code> option needs to retransmit it if it does not receive it back. This is illustrated in <a class="reference internal" href="#fig-mptcp-addaddr"><span class="std std-numref">Fig. 48</span></a>.</p>
<div class="figure" id="id65" style="text-align: center">
<span id="fig-mptcp-addaddr"></span><p><img  src="_images/tikz-41e18c50ca6466fc0f3af543c5aaa3d79dba4151.png" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 48 </span><span class="caption-text">Thanks to the Echo bit, a Multipath TCP host can retransmit lost ADD_ADDR options.</span></p>
</div><p>Thanks to the <code class="docutils literal notranslate"><span class="pre">ADD_ADDR</span></code> option, a host can advertise all its addresses at the beginning of a Multipath TCP connection. Since the option can be sent at any time, a mobile host that learns a new address, e.g. a smartphone attached to a new Wi-Fi network, can advertise it immediately. This makes Multipath TCP agile on mobile hosts. A host may also stop being able to use an IP address. This occurs when a mobile hosts goes away from a wireless network. In this case, the host should inform its peer about the loss of the corresponding address. This is the role of the <code class="docutils literal notranslate"><span class="pre">REMOVE_ADDR</span></code> option that contains the numeric identifier of the removed address. In contrast with the <code class="docutils literal notranslate"><span class="pre">ADD_ADDR</span></code> option, the <code class="docutils literal notranslate"><span class="pre">REMOVE_ADDR</span></code> option is not authenticated using a truncated HMAC. The protocol specification suggests that when a host receives a <code class="docutils literal notranslate"><span class="pre">REMOVE_ADDR</span></code> option, it should first check whether it is currently used by an active subflow. If no, the address can be removed. If yes, it should send a TCP Keepalive on this subflow to verify whether the address still works. If it does not receive a response to its keepalive, the address can be removed and the associated subflow is reset. Otherwise, the <code class="docutils literal notranslate"><span class="pre">REMOVE_ADDR</span></code> option is ignored.</p>
<p>Multipath TCP hosts use the <code class="docutils literal notranslate"><span class="pre">ADD_ADDR</span></code> and <code class="docutils literal notranslate"><span class="pre">REMOVE_ADDR</span></code> options to maintain the list of addresses used by their peer. However, this is not the only source of information that Multipath TCP uses. A Multipath TCP hosts also learns the source addresses of the established subflows. The first addresses are those used for the initial subflow. The client remembers the server’s address as address <code class="docutils literal notranslate"><span class="pre">0</span></code> on this Multipath TCP connection. The server does the same with the client address. When the client creates a new subflow, it places the numeric identifier of the source address of this subflow in the <code class="docutils literal notranslate"><span class="pre">MP_JOIN</span></code> option. This enables the server to learn additional addresses and their associated numeric identifiers. This is illustrated in <a class="reference internal" href="#fig-mptcp-addr-management"><span class="std std-numref">Fig. 49</span></a>. The server first learns that the client is reachable via the address used for the initial subflow ($IP_{A}$). The identifier of this address is $0$. Then, the server learns that the client is also reachable through IP address $IP_{B}$. Thanks to the identifier contained in the <code class="docutils literal notranslate"><span class="pre">MP_JOIN</span></code> option, the server also learns the identifier ($2$) of this address. Then, the server learns the third address ($IP_{C}$) using the <code class="docutils literal notranslate"><span class="pre">ADD_ADDR</span></code> option.</p>
<div class="figure" id="id66" style="text-align: center">
<span id="fig-mptcp-addr-management"></span><p><img  src="_images/tikz-06c84da40708de391f2ef52da8bcb5fa2c3f9a65.png" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 49 </span><span class="caption-text">A Multipath TCP hosts remembers the addresses used by its peer</span></p>
</div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Is the <code class="docutils literal notranslate"><span class="pre">ADD_ADDR</span></code> option required on all Multipath TCP hosts ?</p>
<p>The previous section has explained how Multipath TCP hosts learn the addresses of their peers by using the <code class="docutils literal notranslate"><span class="pre">ADD_ADDR</span></code> and <code class="docutils literal notranslate"><span class="pre">REMOVE_ADDR</span></code> options. These options are important for a server that has multiple addresses (e.g. an IPv4 and an IPv6 address) and wants to advertise them to its clients. On the other hand, servers rarely create subflows and thus they do not really need to learn the client addresses. In fact, Apple’s implementation of Multipath TCP on the iPhones does not use the <code class="docutils literal notranslate"><span class="pre">ADD_ADDR</span></code> option. iPhones simply create subflows over the cellular and Wi-Fi interfaces as when needed and the server relies on the <code class="docutils literal notranslate"><span class="pre">MP_JOIN</span></code> option to validate these subflows. It is interesting to note that the <code class="docutils literal notranslate"><span class="pre">REMOVE_ADDR</span></code> option remains useful even if the <code class="docutils literal notranslate"><span class="pre">ADD_ADDR</span></code> option is not used. Consider a smartphone that has created an initial subflow over its Wi-Fi interface and a second subflow over the cellular one. If the smartphone looses its Wi-Fi interface, it can send a <code class="docutils literal notranslate"><span class="pre">REMOVE_ADDR</span></code> option over the subflow that uses the cellular interface to inform the server that it cannot be reached anymore through its Wi-Fi interface.</p>
</div>
</div>
<div class="section" id="data-transfer">
<span id="mptcp-data-transfer"></span><h2>Data transfer<a class="headerlink" href="#data-transfer" title="Permalink to this headline">¶</a></h2>
<p>Thanks to the <code class="docutils literal notranslate"><span class="pre">MP_CAPABLE</span></code> and <code class="docutils literal notranslate"><span class="pre">MP_JOIN</span></code> option, Multipath TCP hosts can associate one of more subflows to a Multipath TCP connection. Each host can send and receive data on ony of the established subflows. As these subflows follow different paths, packets experience different delays. To preserve the in-order bytestream, the receiver must be able to reorder the data received over the different subflows.</p>
<p>A simple approach to perform this reordering would be to rely on the TCP sequence number that is included in the TCP header. This approach is illustrated in <a class="reference internal" href="#fig-mptcp-dss-naive"><span class="std std-numref">Fig. 50</span></a>. The client creates two subflows and uses the same initial sequence numbers on the different subflows. The server also selects the same initial sequence numbers. The client then sends three bytes: <code class="docutils literal notranslate"><span class="pre">A</span></code> over the initial subflow, <code class="docutils literal notranslate"><span class="pre">B</span></code> over the second subflow and <code class="docutils literal notranslate"><span class="pre">C</span></code> over the initial one. Each byte has its own sequence number and the receiver can reorder them. However, note that sequence number <code class="docutils literal notranslate"><span class="pre">x+2</span></code> is not sent over the initial subflow. Furthermore, sequence numbers <code class="docutils literal notranslate"><span class="pre">x+1</span></code> and <code class="docutils literal notranslate"><span class="pre">x+3</span></code> are not sent over the second subflow.</p>
<div class="figure" id="id67" style="text-align: center">
<span id="fig-mptcp-dss-naive"></span><p><img  src="_images/tikz-2d0a4747d62bb150626da60602655bc27ac794e4.png" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 50 </span><span class="caption-text">A naïve approach to exchange data over different subflows</span></p>
</div><p>Unfortunately, this simple approach suffers from several problems. First, it assumes that the client and the server use the same initial sequence numbers. On the client side, this might be feasible, but on the server side, this would prohibit the utilisation of techniques such as SYN cookies that are important to protect from denial of service attacks. Another concern is that there will be gaps in the sequence numbers that are used over each path. These gaps might cause problems with middleboxes such as firewalls. The same problem applies for the acknowledgments. Although TCP supports selective acknowledgments <span class="target" id="index-0"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2018.html"><strong>RFC 2018</strong></a>, these were not designed to support a large number of gaps.</p>
<p>Multipath TCP solves these problems by using a second level of sequence numbers that are encoded inside TCP options. Conceptually, Multipath TCP associates a data sequence number to the first byte of the payload of each TCP packet. Each Multipath TCP packet carries two different sequence numbers. The first is the sequence number that is included in the TCP header and is called the subflow sequence number. This sequence number plays the same role as in a regular TCP connection. It enables the receiver to reorder the received packets on a given subflow and detect losses. The data sequence number corresponds to the bytestream. It indicates the position of the first byte of the payload of the TCP packet in the bytestream. This data sequence number is used by the receiver to reorder the data received over different subflows and detect losses at this level. Multipath TCP also uses acknowledgments to confirm the reception of data. At the subflow level these are regular TCP acknowledgments (or selective acknowledgments if this extension is active). At the Multipath TCP connection level, the receiver always returns a data acknowledgment that contains the next expected in-sequence data sequence number. This is illustrated in <a class="reference internal" href="#fig-mptcp-dss-concept"><span class="std std-numref">Fig. 51</span></a>.</p>
<p>The client sends the first byte of the bytestream over the initial subflow. This byte is sent in a TCP packet whose sequence number is <code class="docutils literal notranslate"><span class="pre">x+1</span></code>. It carries a Multipath TCP option that contains the data sequence number, i.e. <code class="docutils literal notranslate"><span class="pre">0</span></code> since this is the first byte of the bytestream. The server returns an acknowledgment that indicates that the <code class="docutils literal notranslate"><span class="pre">x+2</span></code> is the next expected sequence number over the initial subflow. This TCP ACK also contains a Multipath TCP option that indicates that <code class="docutils literal notranslate"><span class="pre">1</span></code> is the next expected data sequence number. The sends the second byte over the second subflow. For this, it sends a packet whose sequence number is set to <code class="docutils literal notranslate"><span class="pre">w+1</span></code>, i.e. the first sequence number over this subflow. This packet contains a Multipath TCP option that indicates that this is the second byte (data sequence set to <code class="docutils literal notranslate"><span class="pre">1</span></code>) of the bytestream. The server confirms the reception of this packet with an acknowledgment.</p>
<div class="figure" id="id68" style="text-align: center">
<span id="fig-mptcp-dss-concept"></span><p><img  src="_images/tikz-d437874c5d8c8a4f31457c97a446dc0202d0e76c.png" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 51 </span><span class="caption-text">Multipath TCP relies on data sequence numbers and acknowledgements</span></p>
</div><p><a class="reference internal" href="#fig-mptcp-dss-concept2"><span class="std std-numref">Fig. 52</span></a> shows a slightly different example where the first data packet sent by the client is lost. When the server receives the second byte of the bytestream on the second subflow, it acknowledges it at the subflow level (<code class="docutils literal notranslate"><span class="pre">ack=w+2</span></code>) but not at the connection level since the previous byte of the bytestream is missing. The server stores the received byte in the reordering buffer associated with the connection. When the server receives the second packet sent over the initial subflow, it stores it in the buffer associated with the initial subflow. Since it has neither received the byte that has sequence number <code class="docutils literal notranslate"><span class="pre">x+1</span></code> on the initial subflow, it cannot update its acknowledgment number. It could send a selective acknowledgment if these were enabled on the connection. The retransmission of the first data packet sent over the initial subflow fills the buffer associated to this subflow. The server can thus update the subflow level acknowledgment number (<code class="docutils literal notranslate"><span class="pre">ack=x+2</span></code>). The data received in order can now be passed to the connection-level buffer. The data at this level is also in-sequence and the server returns a data acknowledgment indicating that the next data sequence number it expects is <code class="docutils literal notranslate"><span class="pre">3</span></code>. The three bytes <code class="docutils literal notranslate"><span class="pre">ABC</span></code> are delivered in sequence to the server application.</p>
<div class="figure" id="id69" style="text-align: center">
<span id="fig-mptcp-dss-concept2"></span><p><img  src="_images/tikz-0f068d2388a2e1a4998a4b84dc6cbcde58016c5a.png" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 52 </span><span class="caption-text">Multipath TCP copes with packet losses</span></p>
</div><p>The example of <a class="reference internal" href="#fig-mptcp-dss-concept2"><span class="std std-numref">Fig. 52</span></a> showed how Multipath TCP copes with packet losses. These are frequent events on a TCP connection. A Multipath TCP only needs to cope with the loss of an entire subflow. Consider the same example as above, but the initial subflow was established over a Wi-Fi interface that stops shortly after the reception of the acknowledgment for the second data packet. The client detects the problem and sends a <code class="docutils literal notranslate"><span class="pre">REMOVE_ADDR</span></code> over the second subflow. It also retransmits the first packet that had not been acknowledged, but this time over the second subflow.</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<span class="docutils literal">\tikzmath{\c1=1;\c2=1.5; \s1=8; \s2=8.5; \max=11; }

\tikzstyle{arrow} = [thick,-&gt;,&gt;=stealth]
\tikzset{state/.style={rectangle, dashed, draw, fill=white} }
\node [black, fill=white] at (\c1,\max+0.5) {Client};
\node [black, fill=white] at (\s1,\max+0.5) {Server};

\draw[blue,very thick,-&gt;] (\c1,\max-0.5) -- (\c1,0.5);
\draw[black,very thick,-&gt;] (\s1,\max-0.5) -- (\s1,0.5);
\draw[red,very thick,-&gt;] (\c2,\max-0.5) -- (\c2,0.5);


\tikzmath{\y=\max-1;}


\draw[blue,thick, -Circle] (\c1,\y) -- (\s1,\y-1) node [midway, align=left, fill=white] {[seq=x+1]\small{DS[s=0]} &quot;A&quot;};

\draw[red,thick, -&gt;] (\c2,\y-2) -- (\s1,\y-3) node [midway, align=left, fill=white] {[seq=w+1]\small{DS[s=1]} &quot;B&quot;};
\draw[red,thick, -&gt;] (\s1,\y-3) -- (\c2,\y-4) node [midway, align=left, fill=white] {ACK [ack=w+2]\small{DS[a=0]}};
\draw[blue,thick, -&gt;] (\c1,\y-4) -- (\s1,\y-5) node [midway, align=left, fill=white] {[seq=x+2]\small{DS[s=2]} &quot;C&quot;};
\draw[blue,thick, -&gt;] (\s1,\y-5) -- (\c1,\y-6) node [midway, align=left, fill=white] {ACK [ack=x+1]\small{DS[a=0]}};

\draw[red,thick, -&gt;] (\c2,\y-6.5) -- (\s1,\y-7.5) node [midway, align=left, fill=white] {\small{REMODE\_ADDR[id=0]}};

\draw[red,thick, -&gt;] (\c2,\y-7) -- (\s1,\y-8) node [midway, align=left, fill=white] {[seq=w+2]\small{DS[s=0]} &quot;A&quot;};
\draw[red,thick, -&gt;] (\s1,\y-8) -- (\c2,\y-9) node [midway, align=left, fill=white] {ACK [ack=w+3]\small{DS[a=3]}};</span>)</p>
<p>! Package tikz Error: I did not find the tikz library 'arrows.metamath'. I look
ed for files named tikzlibraryarrows.metamath.code.tex and pgflibraryarrows.met
amath.code.tex, but neither could be found in the current texmf trees..

See the tikz package documentation for explanation.
Type  H &lt;return&gt;  for immediate help.
 ...                                              
                                                  
l.6 ...{positioning,matrix,arrows,arrows.metamath}
                                                  
(/usr/share/texlive/texmf-dist/tex/generic/ulem/ulem.sty)
(/usr/share/texlive/texmf-dist/tex/latex/l3backend/l3backend-pdfmode.def)
No file tikz-98ba3d103ab55e0db634c83e95ba913bbf854245.aux.
ABD: EveryShipout initializing macros
(/usr/share/texlive/texmf-dist/tex/context/base/mkii/supp-pdf.mkii
[Loading MPS to PDF converter (version 2006.09.02).]
) (/usr/share/texlive/texmf-dist/tex/latex/epstopdf-pkg/epstopdf-base.sty
(/usr/share/texlive/texmf-dist/tex/generic/infwarerr/infwarerr.sty)
(/usr/share/texlive/texmf-dist/tex/latex/grfext/grfext.sty
(/usr/share/texlive/texmf-dist/tex/generic/kvdefinekeys/kvdefinekeys.sty))
(/usr/share/texlive/texmf-dist/tex/latex/kvoptions/kvoptions.sty
(/usr/share/texlive/texmf-dist/tex/generic/ltxcmds/ltxcmds.sty)
(/usr/share/texlive/texmf-dist/tex/generic/kvsetkeys/kvsetkeys.sty))
(/usr/share/texlive/texmf-dist/tex/latex/pdftexcmds/pdftexcmds.sty)
(/usr/share/texlive/texmf-dist/tex/latex/latexconfig/epstopdf-sys.cfg))

Package pgfplots Warning: running in backwards compatibility mode (unsuitable t
ick labels; missing features). Consider writing \\pgfplotsset{compat=1.16} into 
your preamble.
 on input line 19.

! Undefined control sequence.
&lt;recently read&gt; \\tikzmath 
                          
l.21 \\tikzmath
              {\\c1=1;\\c2=1.5; \\s1=8; \\s2=8.5; \\max=11; }
! Undefined control sequence.
l.21 \\tikzmath{\\c1=1;\\c2=1.5; \\s
                                1=8; \\s2=8.5; \\max=11; }
! Undefined control sequence.
l.21 \\tikzmath{\\c1=1;\\c2=1.5; \\s1=8; \\s
                                       2=8.5; \\max=11; }
! Missing $ inserted.
&lt;inserted text&gt; 
                $
l.21 \\tikzmath{\\c1=1;\\c2=1.5; \\s1=8; \\s2=8.5; \\max
                                                  =11; }
! Extra }, or forgotten $.
l.21 ...{\\c1=1;\\c2=1.5; \\s1=8; \\s2=8.5; \\max=11; }
                                                  
! TeX capacity exceeded, sorry [input stack size=5000].
\\&#64;spaces -&gt;\\space 
                  \\space \\space \\space 
l.24 \
ode [black, fill=white] at (\\c1,\\max+0.5)
                                                 {Client};
!  ==&gt; Fatal error occurred, no output PDF file produced!
Transcript written on tikz-98ba3d103ab55e0db634c83e95ba913bbf854245.log.
&quot;</p>
</div>
<p class="caption"><span class="caption-number">Fig. 53 </span><span class="caption-text">Multipath TCP copes with subflow failures</span></p>
</div><p>Conceptually, a Multipath TCP implementation can be viewed as composed of a set of queues. On the sender side, the bytestream is pushed in a queue that keeps the data until it has been acknowledgded at the connection level. A packet scheduler extracts blocks of data from this queue and places them with the associated date sequence numbers in the per-subflow queues that represent the sending buffers associated to each subflow. TCP uses these per-subflow queues to send the data and perform the retransmission when required. On the receiver side, there is one queue associated with each subflow. This queue corresponds to the TCP receive buffer. TCP uses this queue to reorder the received data based on their TCP sequence numbers, but does not deal with the data sequence numbers that are contained in TCP options. Once data is in-order in a subflow receive buffer, it goes in the connection-level reorder queue that uses the data sequence numbers contained in TCP options to recover the bytestream. Multipath TCP creates the data sequence acknowledgments from the data contained in this buffer. Once data is in-sequence inside this buffer, it is passed to the application through a <code class="docutils literal notranslate"><span class="pre">recv</span></code> system call.</p>
<div class="figure" id="id71" style="text-align: center"><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 54 </span><span class="caption-text">Architecture of a Multipath TCP implementation</span></p>
</div></div>
<div class="section" id="congestion-control">
<span id="mptcp-congestion"></span><h2>Congestion control<a class="headerlink" href="#congestion-control" title="Permalink to this headline">¶</a></h2>
<div class="admonition-todo admonition" id="id26">
<p class="admonition-title">Todo</p>
<p>explain basic idea and the problem of having</p>
</div>
<div class="section" id="lia">
<h3>LIA<a class="headerlink" href="#lia" title="Permalink to this headline">¶</a></h3>
<p><span id="id27">[<a class="reference internal" href="biblio.html#id8922" title="Damon Wischik, Costin Raiciu, Adam Greenhalgh, and Mark Handley. Design, implementation and evaluation of congestion control for Multipath TCP. In Proceedings of the 8th USENIX Conference on Networked Systems Design and Implementation, NSDI'11, 99–112. Berkeley, CA, USA, 2011. USENIX Association. URL: http://dl.acm.org/citation.cfm?id=1972457.1972468.">58</a>]</span> and <span id="id28">[<a class="reference internal" href="biblio.html#id6203" title="C. Raiciu, M. Handley, and D. Wischik. Coupled Congestion Control for Multipath Transport Protocols. RFC 6356 (Experimental), October 2011. URL: https://www.rfc-editor.org/rfc/rfc6356.txt, doi:10.17487/RFC6356.">59</a>]</span></p>
</div>
<div class="section" id="olia">
<h3>OLIA<a class="headerlink" href="#olia" title="Permalink to this headline">¶</a></h3>
<p><span id="id29">[<a class="reference internal" href="biblio.html#id8941" title="R. Khalili, N. Gast, M. Popovic, and J.-Y. Le Boudec. MPTCP is not pareto-optimal: performance issues and a possible solution. Networking, IEEE/ACM Transactions on, 21(5):1651-1665, Oct 2013. doi:10.1109/TNET.2013.2274462.">60</a>]</span></p>
</div>
<div class="section" id="balia">
<h3>BALIA<a class="headerlink" href="#balia" title="Permalink to this headline">¶</a></h3>
<p><span id="id30">[<a class="reference internal" href="biblio.html#id8983" title="Qiuyu Peng, Anwar Walid, Jaehyun Hwang, and Steven H Low. Multipath tcp: analysis, design, and implementation. IEEE/ACM Transactions on networking, 24(1):596–609, 2014.">61</a>]</span></p>
</div>
<div class="section" id="mpcc">
<h3>MPCC<a class="headerlink" href="#mpcc" title="Permalink to this headline">¶</a></h3>
<p><span id="id31">[<a class="reference internal" href="biblio.html#id8992" title="Tomer Gilad, Neta Rozen-Schiff, P Brighten Godfrey, Costin Raiciu, and Michael Schapira. Mpcc: online learning multipath transport. In Proceedings of the 16th International Conference on emerging Networking EXperiments and Technologies, 121–135. 2020.">62</a>]</span></p>
</div>
</div>
<div class="section" id="connection-release">
<span id="mptcp-release"></span><h2>Connection release<a class="headerlink" href="#connection-release" title="Permalink to this headline">¶</a></h2>
<div class="admonition-todo admonition" id="id32">
<p class="admonition-title">Todo</p>
<p>keepalive and end of a connection</p>
</div>
<p>A TCP connection starts with a three-way handshake and ends with either the exchange of <code class="docutils literal notranslate"><span class="pre">FIN</span></code> packets to gracefully terminate the connection or when one of the hosts sends a <code class="docutils literal notranslate"><span class="pre">RST</span></code> packet. The main benefit of the graceful termination is that both hosts receive the confirmation that all the data that they have sent over the connection has been correctly received. Multipath also supports a graceful termination of the connection. As in regular TCP, this graceful termination is implemented by using a flag that indicates the end of the bytestream. This flag is included in the Data Sequence Number option.</p>
<p><a class="reference internal" href="#fig-mptcp-close"><span class="std std-numref">Fig. 55</span></a> illustrates a graceful Multipath TCP connection release. We assume that the connection has two active subflows. The client sends <code class="docutils literal notranslate"><span class="pre">XYZ</span></code> over the initial subflow. Since this is the last byte sent over the bytestream, it adds the <code class="docutils literal notranslate"><span class="pre">DATA_FIN</span></code> flag to the data sequence option. This flag consummes one data sequence number as the <code class="docutils literal notranslate"><span class="pre">FIN</span></code> flag in the TCP header. The server returns an acknowledgment that confirms the reception of the three bytes at the subflow level (<code class="docutils literal notranslate"><span class="pre">ack=x+3</span></code>). At the connection level, four sequence numbers are acknowledged (<code class="docutils literal notranslate"><span class="pre">a=y+4</span></code>) since the <code class="docutils literal notranslate"><span class="pre">DATA_FIN</span></code> flag consummes one sequence number. The server decides to close its bytestream by sending its last byte, <code class="docutils literal notranslate"><span class="pre">M</span></code>, over the second subflow with the <code class="docutils literal notranslate"><span class="pre">DATA_FIN</span></code> flag set. At this point, the Multipath TCP has been gracefully closed. No data will be exchanged over the different subflows. The client and/or the server can terminate the subflows by using packets with either the <code class="docutils literal notranslate"><span class="pre">FIN</span></code> or the <code class="docutils literal notranslate"><span class="pre">RST</span></code> flag in the TCP header.</p>
<div class="figure" id="id72" style="text-align: center">
<span id="fig-mptcp-close"></span><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 55 </span><span class="caption-text">Graceful termination of a Multipath TCP connection</span></p>
</div><p>The main drawback of exchanging <code class="docutils literal notranslate"><span class="pre">DATA_FINs</span></code> to terminate a Multipath TCP is that this takes time. Busy servers might not be willing to spend a long time waiting for the exchange of all these packets if the application already guarantees the correct delivery of the data. A regular TCP server would send a <code class="docutils literal notranslate"><span class="pre">RST</span></code> packet to quickly terminate such a connection. However, such <code class="docutils literal notranslate"><span class="pre">RST</span></code> packets can lead to denial of service attacks <span id="id33">[<a class="reference internal" href="biblio.html#id5818" title="A. Ramaiah, R. Stewart, and M. Dalal. Improving TCP's Robustness to Blind In-Window Attacks. RFC 5961 (Proposed Standard), August 2010. URL: https://www.rfc-editor.org/rfc/rfc5961.txt, doi:10.17487/RFC5961.">63</a>]</span>. A regular TCP receiver mitigates these attacks by checking the sequence number of the <code class="docutils literal notranslate"><span class="pre">RST</span></code> packet <span id="id34">[<a class="reference internal" href="biblio.html#id5558" title="F. de Bont, S. Doehla, M. Schmidt, and R. Sperschneider. RTP Payload Format for Elementary Streams with MPEG Surround Multi-Channel Audio. RFC 5691 (Proposed Standard), October 2009. URL: https://www.rfc-editor.org/rfc/rfc5691.txt, doi:10.17487/RFC5691.">64</a>]</span>. The Multipath TCP designers did not consider this approach to be safe since an attacker who is able to observe the packets on one path could send a <code class="docutils literal notranslate"><span class="pre">RST</span></code> packet that would terminate all the subflows used by the connection.</p>
<p>To still allow a host to quickly terminate a Multipath TCP connection, Multipath TCP must be able to verify the validaty of a packet that terminates a connection. For this, Multipath TCP defines the <code class="docutils literal notranslate"><span class="pre">FAST_CLOSE</span></code> option that includes a 64 bits security key. These keys are exchanged during the initial handshake and included in the state associated to a Multipath TCP connection. To quickly close a connection, a host simply needs to send the key of the remote host in a <code class="docutils literal notranslate"><span class="pre">FAST_CLOSE</span></code> option sent over one of the active subflows. The Multipath TCP specification defines two different methods to use the <code class="docutils literal notranslate"><span class="pre">FAST_CLOSE</span></code> option.</p>
<p>The first solution is to send the <code class="docutils literal notranslate"><span class="pre">FAST_CLOSE</span></code> option inside an <code class="docutils literal notranslate"><span class="pre">ACK</span></code>. Upon reception of such a packet, a host sends a <code class="docutils literal notranslate"><span class="pre">RST</span></code> over all active subflows. This is illustrated in <a class="reference internal" href="#fig-mptcp-fastclose-a"><span class="std std-numref">Fig. 56</span></a>.</p>
<div class="figure" id="id73" style="text-align: center">
<span id="fig-mptcp-fastclose-a"></span><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 56 </span><span class="caption-text">Abrupt release of a Multipath TCP connection by sending FAST_CLOSE inside an ACK</span></p>
</div><div class="figure" id="id74" style="text-align: center">
<span id="fig-mptcp-fastclose-b"></span><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 57 </span><span class="caption-text">Abrupt release of a Multipath TCP connection by sending a RST with FAST_CLOSE on all subflows</span></p>
</div></div>
<div class="section" id="coping-with-middlebox-interference">
<span id="mptcp-middlebox"></span><h2>Coping with middlebox interference<a class="headerlink" href="#coping-with-middlebox-interference" title="Permalink to this headline">¶</a></h2>
<p>The previous sections have explained how Multipath TCP operates at a high level. They assume a simple network that is mainly composed of hosts, switches and routers. TCP and Multipath TCP are used by the hosts. They rely on IP packets that contain the TCP segments. These packets are forwarded by IP routers and possibly switches at layer-2 before reaching their final destination. In a network that uses layered protocols, the switches only inspect the layer-2 headers, the routers only read and change the layer-2 and layer-3 headers. Neither the switches nore the routers read or modify the payload of the packets that they forward. Unfortunately, this assumption is not true on the global Internet and in enterprise networks. Besides switches and routers, these networks contains other types of equipment that process packets <span id="id35">[<a class="reference internal" href="biblio.html#id8911" title="Justine Sherry, Shaddi Hasan, Colin Scott, Arvind Krishnamurthy, Sylvia Ratnasamy, and Vyas Sekar. Making middleboxes someone else's problem: network processing as a cloud service. ACM SIGCOMM Computer Communication Review, 42(4):13–24, 2012.">36</a>]</span>. These devices are usually called middleboxes because they reside in the middle of the network and process packets in different ways. A detailed survey of all the different types of middleboxes is outside the scope of this document. We discuss below some of the popular middleboxes and analyze how they have influenced the design of Multipath TCP.</p>
<p>Our first middlebox is a firewall. A firewall is a device that receives packets, analyzes their contents and then forwards or blocks the packet. The simplest firewalls are the stateless firewalls that accept or reject each individual packet. Such a firewall can accept packet based on the source or destination addresses or port numbers. Some firewalls also check the flags or the IP header or reassemble the received packet fragments. Others analyze the TCP header and verify the utilization of the TCP options. A firewall can be configured using a white list or a black list. A white list specifies all the packet fields that are valid and all the others are invalid. On the other hand, a black list specifies the packets that must be rejected by the firewall and all the others are accepted. Many firewalls use a small white list that defines the TCP options that the firewall accepts. This list typically includes the widely deployed options such as MSS <span id="id36">[<a class="reference internal" href="biblio.html#id729" title="J. Postel. Transmission Control Protocol. RFC 793 (Internet Standard), September 1981. Updated by RFCs 1122, 3168, 6093, 6528. URL: https://www.rfc-editor.org/rfc/rfc793.txt, doi:10.17487/RFC0793.">5</a>]</span>, timestamps <span id="id37">[<a class="reference internal" href="biblio.html#id7140" title="K. Patel, E. Chen, and B. Venkatachalapathy. Enhanced Route Refresh Capability for BGP-4. RFC 7313 (Proposed Standard), July 2014. URL: https://www.rfc-editor.org/rfc/rfc7313.txt, doi:10.17487/RFC7313.">65</a>]</span>, windows scale <span id="id38">[<a class="reference internal" href="biblio.html#id1245" title="C. Partridge. Today's Programming for KRFC AM 1313 Internet Talk Radio. RFC 1313 (Informational), April 1992. URL: https://www.rfc-editor.org/rfc/rfc1313.txt, doi:10.17487/RFC1313.">66</a>]</span> and selective acknowledgements <span id="id39">[<a class="reference internal" href="biblio.html#id1948" title="M. Mathis, J. Mahdavi, S. Floyd, and A. Romanow. TCP Selective Acknowledgment Options. RFC 2018 (Proposed Standard), October 1996. URL: https://www.rfc-editor.org/rfc/rfc2018.txt, doi:10.17487/RFC2018.">13</a>]</span>. TCP options are encoded using the Kind, Length, Value format shown in <a class="reference internal" href="#fig-mptcp-tcp-option"><span class="std std-numref">Fig. 58</span></a>.</p>
<div class="figure" id="id75" style="text-align: center">
<span id="fig-mptcp-tcp-option"></span><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 58 </span><span class="caption-text">The generic format for TCP options</span></p>
</div><p>It is interesting to explore how such a firewall reacts when it receives a packet containing a TCP option that is not part of its whitelist. There are two possibilities. Some firewalls simply drop the packet, but this blocks a connection that could be totally legitimate. Other firewalls remove the option from the TCP header. This can be done by either removing the bytes that contain the unknown TCP option, adjust the Length field of the IP header, the TCP Header length (and possiblly update the padding) and update the TCP checksum. A simpler approach is to replace the bytes of the option with byte <code class="docutils literal notranslate"><span class="pre">1</span></code>. This corresponds to the standard No-Operation TCP option <span id="id40">[<a class="reference internal" href="biblio.html#id729" title="J. Postel. Transmission Control Protocol. RFC 793 (Internet Standard), September 1981. Updated by RFCs 1122, 3168, 6093, 6528. URL: https://www.rfc-editor.org/rfc/rfc793.txt, doi:10.17487/RFC0793.">5</a>]</span>. The advantage of this approach is that the firewall only has to recompute the TCP checksum and does not need to adjust the packet length and move data.</p>
<p>The removal of TCP options by firewalls has influenced the design of Multipath TCP. Multipath TCP uses TCP options to exchange different types of information. The information carried in a <code class="docutils literal notranslate"><span class="pre">SYN</span></code> is not the same as the one exchanged in data packets. The selective acknowledgments TCP extension <span id="id41">[<a class="reference internal" href="biblio.html#id1948" title="M. Mathis, J. Mahdavi, S. Floyd, and A. Romanow. TCP Selective Acknowledgment Options. RFC 2018 (Proposed Standard), October 1996. URL: https://www.rfc-editor.org/rfc/rfc2018.txt, doi:10.17487/RFC2018.">13</a>]</span> defines two different options: a two bytes long <code class="docutils literal notranslate"><span class="pre">SACK</span> <span class="pre">permitted</span></code> that is used inside <code class="docutils literal notranslate"><span class="pre">SYN</span></code> and a variable length <code class="docutils literal notranslate"><span class="pre">SACK</span></code> option that carries the selective acknowledgments during the data transfer. The first versions of Multipath TCP used a similar approach with different TCP options kinds. However, the Multipath TCP designers feared that some firewalls could accept some of the Multipath TCP options and drop the others. For example, the Multipath TCP option used in the <code class="docutils literal notranslate"><span class="pre">SYN</span></code> could pass a firewall that would later drop the options used in data packets. It would have been very difficult for a Multipath TCP implementation to deal with all the corner cases that could happen since Multipath TCP <span id="id42">[<a class="reference internal" href="biblio.html#id8500" title="A. Ford, C. Raiciu, M. Handley, O. Bonaventure, and C. Paasch. TCP Extensions for Multipath Operation with Multiple Addresses. RFC 8684 (Proposed Standard), March 2020. URL: https://www.rfc-editor.org/rfc/rfc8684.txt, doi:10.17487/RFC8684.">49</a>]</span> currently defines 9 different options. To prevent such problems, Multipath TCP uses a single TCP option kind and each Multipath TCP option contains a subtype field. This increases the length of the Multipath TCP options, but minimizes the risk of middlebox interference.</p>
<div class="figure" id="id76" style="text-align: center">
<span id="fig-mptcp-tcp-option2"></span><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 59 </span><span class="caption-text">The generic format for Multipath TCP options</span></p>
</div><p>Before looking at other middleboxes, it is interesting to analyze how a router forwards an IP packet that contains a TCP segment. Consider a router that receives a packet such as the one shown in <a class="reference internal" href="#fig-mptcp-ip4tcp"><span class="std std-numref">Fig. 60</span></a>. When a router forwards such a packet, it will read the IP header and may modify the fields highlighted in red:</p>
<blockquote>
<div><ul class="simple">
<li><p>the Differentiated Services Codepoint (DSCP)</p></li>
<li><p>the Explicit Congestion Notification flags (the CE bit)</p></li>
<li><p>decrement the Time to Live</p></li>
<li><p>update the Ip header checksum</p></li>
</ul>
</div></blockquote>
<p>A router will never change any other field of the IP header and will not read the packet payload.</p>
<div class="figure" id="id77" style="text-align: center">
<span id="fig-mptcp-ip4tcp"></span><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 60 </span><span class="caption-text">Fields of an IPv4 packet carrying a TCP segment which can be modified by a router</span></p>
</div><p>Today, most TCP stacks set the Don’t Fragment flag when sending TCP packets. This implies that IPv4 routers will not fragment the packet. Even if a router fragments an IPv4 packet, this is transparent for the TCP stack since the IP stack on the receiver will reassemble the packet before passing its contents to TCP.</p>
<p>Unfortunately, deployed networks also contain Network Address Translators (NAT) <span id="id43">[<a class="reference internal" href="biblio.html#id2952" title="P. Srisuresh and K. Egevang. Traditional IP Network Address Translator (Traditional NAT). RFC 3022 (Informational), January 2001. URL: https://www.rfc-editor.org/rfc/rfc3022.txt, doi:10.17487/RFC3022.">40</a>]</span>. We consider three different types of NATs because they interfe in different ways with TCP extensions such as Multipath TCP. A NAT is usually located at the boundary between a private network and the Internet. The hosts of the private network use private IP addresses <span id="id44">[<a class="reference internal" href="biblio.html#id1848" title="Y. Rekhter, B. Moskowitz, D. Karrenberg, G. J. de Groot, and E. Lear. Address Allocation for Private Internets. RFC 1918 (Best Current Practice), February 1996. Updated by RFC 6761. URL: https://www.rfc-editor.org/rfc/rfc1918.txt, doi:10.17487/RFC1918.">67</a>]</span> and the NAT is configured with a pool of public addresses. When the NAT receives an IP packet from a host in the private network, its maps the source IP address to a public one and rewrites the packet before forwarding it to the public Internet. When the NAT receives a packet from the Internet, it checks if there is a mapping for the packet’s destination address. If so, the destination address is translated and the packet is forwarded to the private host.</p>
<div class="figure" id="id78" style="text-align: center">
<span id="fig-mptcp-ip4tcp-nat"></span><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 61 </span><span class="caption-text">Fields of an IPv4 packet carrying a TCP segment which can be modified by a simple NAT</span></p>
</div><p>As illustrated in <a class="reference internal" href="#fig-mptcp-ip4tcp-nat"><span class="std std-numref">Fig. 61</span></a>, this NAT updates the source or destination address of the packet depending on the packet direction. This modification forces the NAT to recompute the IP checksum but also the TCP checksum since it covers the TCP packet and a pseudo header that includes the IP addresses <span id="id45">[<a class="reference internal" href="biblio.html#id729" title="J. Postel. Transmission Control Protocol. RFC 793 (Internet Standard), September 1981. Updated by RFCs 1122, 3168, 6093, 6528. URL: https://www.rfc-editor.org/rfc/rfc793.txt, doi:10.17487/RFC0793.">5</a>]</span>. In practice, these two checksums are incrementally updated <span id="id46">[<a class="reference internal" href="biblio.html#id2952" title="P. Srisuresh and K. Egevang. Traditional IP Network Address Translator (Traditional NAT). RFC 3022 (Informational), January 2001. URL: https://www.rfc-editor.org/rfc/rfc3022.txt, doi:10.17487/RFC3022.">40</a>]</span> and do not need to be recomputed.</p>
<p>Multipath TCP copes with these NATs by associating an identifier to each address that is used to create a subflow or advertise an address using the <code class="docutils literal notranslate"><span class="pre">ADD_ADDR</span></code> option. NAT are not aware of these identifiers and they do not modify them. The <code class="docutils literal notranslate"><span class="pre">REMOVE_ADDR</span></code> option only contains the identifier of the address that was removed. With this information, the receiver of the option can easily determine the affected subflows.</p>
<p>Most NAT deployments, in particular with IPv4, use a pool a public addresses that is much smaller than the set of private addresses that need to be mapped. These middleboxes also need to translate the source ports used by the internal hosts to map different private addresses to the same public addresses. These Network Address and Port Translators (NAPT) also modify the source or destination ports in the same way as they modify the addresses. Multipath TCP copes with simple NAPTs as with simple NATs. Unfortunately, most NATs and NAPTs also include Application-Level Gateways (ALG). ALGs were designed to enable applications such as the File Transfer Protocol (FTP) <span id="id47">[<a class="reference internal" href="biblio.html#id894" title="J. Postel and J. Reynolds. File Transfer Protocol. RFC 959 (Internet Standard), October 1985. Updated by RFCs 2228, 2640, 2773, 3659, 5797, 7151. URL: https://www.rfc-editor.org/rfc/rfc959.txt, doi:10.17487/RFC0959.">41</a>]</span> to be used through NATs and NAPTs. FTP and a few other protocols use IP addresses as parameters of the application-level messages that are exchanged within the bytestream. A simple FTP session is shown in <code class="xref std std-numref docutils literal notranslate"><span class="pre">fig-mptcp-ftp</span></code>. In contrast with many application-level protocols, FTP uses several TCP connection. A FTP sessions starts with a TCP connection established by the client. This connection is called the control connection <span id="id48">[<a class="reference internal" href="biblio.html#id894" title="J. Postel and J. Reynolds. File Transfer Protocol. RFC 959 (Internet Standard), October 1985. Updated by RFCs 2228, 2640, 2773, 3659, 5797, 7151. URL: https://www.rfc-editor.org/rfc/rfc959.txt, doi:10.17487/RFC0959.">41</a>]</span>. This connection is used to exchange simple commands and the associated responses. The client issues commands such as <code class="docutils literal notranslate"><span class="pre">USER</span></code> (to indicate the client username) or <code class="docutils literal notranslate"><span class="pre">PASS</span></code> (to provide a password) as a single ASCII line sent over this connection. The server replies with one line that starts with a decimal number that indicates the success of the failure of the command and a textual explanation. However, this is not the only connection used between the client and the server. The client and the server also use data connections. If the client wants to retrieve a file or simply list the names of the files in a given directory, it needs to issue two successive commands. The first command (<code class="docutils literal notranslate"><span class="pre">PORT</span></code>) indicates the data connection that will be used to exchange the result of the subsequent command. The client listens on a local port and provides its IP address and port number as parameters of the <code class="docutils literal notranslate"><span class="pre">PORT</span></code> command. Upon reception of this command, the server establish a TCP connection towards the port specific by the client. If the client is behind a NAT, its private IP address and the local port must be translated by the NAT to support the establishment of a server-initiated connection.</p>
<div class="highlight-console notranslate" id="fig-mptcp-ftp"><div class="highlight"><pre><span></span><span class="gp">#</span>ftp -4d ftp.belnet.be
<span class="go">Connected to ftp-brudie.belnet.be.</span>
<span class="go">220-Welcome to the Belnet public FTP server ftp.belnet.be !</span>

<span class="go">All access is logged.</span>

<span class="go">Currently used storage capacity : 38T / 100T on /ftp</span>
<span class="go">220 193.190.198.27 FTP server ready</span>
<span class="go">Name (ftp.belnet.be): anonymous</span>
<span class="go">---&gt; USER anonymous</span>
<span class="go">331 Anonymous login ok, send your complete email address as your password</span>
<span class="go">Password:</span>
<span class="go">---&gt; PASS XXXX</span>
<span class="go">230 Anonymous access granted, restrictions apply</span>
<span class="go">---&gt; SYST</span>
<span class="go">215 UNIX Type: L8</span>
<span class="go">Remote system type is UNIX.</span>
<span class="go">Using binary mode to transfer files.</span>
<span class="go">ftp&gt; dir</span>
<span class="go">---&gt; PORT 192,168,0,37,133,67</span>
<span class="go">200 PORT command successful</span>
<span class="go">---&gt; LIST</span>
<span class="go">150 Opening ASCII mode data connection for file list</span>
<span class="go">lrw-r--r--   1 ftp      ftp            16 Feb 24  2021 arcolinux -&gt; mirror/arcolinux</span>
<span class="go">drwxr-xr-x   3 ftp      ftp           101 Jan 12  2021 belnetstyle</span>
<span class="go">lrw-r--r--   1 ftp      ftp            13 Feb  1  2021 debian -&gt; mirror/debian</span>
<span class="go">226 Transfer complete</span>
<span class="go">ftp&gt; quit</span>
<span class="go">---&gt; QUIT</span>
<span class="go">221 Goodbye.</span>
</pre></div>
</div>
<p>It is interesting to analyze how an ALG modifies a packet that carries such a <code class="docutils literal notranslate"><span class="pre">PORT</span></code> command. Let us assume that the <code class="docutils literal notranslate"><span class="pre">PORT</span> <span class="pre">192,168,0,37,133,67</span></code> command is sent in a single TCP packet for simplicity. <a class="reference internal" href="#fig-mptcp-ip4tcp-ftp-port"><span class="std std-numref">Fig. 62</span></a> shows the contents of the packet sent by the client. <a class="reference internal" href="#fig-mptcp-ip4tcp-ftp-port2"><span class="std std-numref">Fig. 63</span></a> shows the packet after its translation by the NAT, assuming that the NAT maps IP address <code class="docutils literal notranslate"><span class="pre">192.168.0.37</span></code> onto address <code class="docutils literal notranslate"><span class="pre">5.6.7.8</span></code>. The packet sent by client contains 26 bytes of payload. The IP packet is thus 66 bytes long.</p>
<div class="figure" id="id79" style="text-align: center">
<span id="fig-mptcp-ip4tcp-ftp-port"></span><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 62 </span><span class="caption-text">Packet carrying PORT command sent by a client</span></p>
</div><p>The <code class="docutils literal notranslate"><span class="pre">PORT</span> <span class="pre">192,168,0,37,133,67</span></code> indicates that the client listens on IP address <code class="docutils literal notranslate"><span class="pre">192.168.0.37</span></code> and on port <span class="math notranslate nohighlight">\(133*256+67=34115\)</span>. Let us assume that the NAT maps this IP address on address <code class="docutils literal notranslate"><span class="pre">5.6.7.8</span></code> and port <code class="docutils literal notranslate"><span class="pre">34115</span></code> on port <span class="math notranslate nohighlight">\(31533=123*256+45\)</span>. In ASCII, the <code class="docutils literal notranslate"><span class="pre">PORT</span></code> commans becomes <code class="docutils literal notranslate"><span class="pre">PORT</span> <span class="pre">5,6,7,8,123,45</span></code> and the NAT sends the packet shown in <a class="reference internal" href="#fig-mptcp-ip4tcp-ftp-port2"><span class="std std-numref">Fig. 63</span></a>. The fields shown in red have been translated by the NAT. An important point to note contains 21 bytes of payload and not 66 as the packet sent by the client. This implies that the packet sent by the NAT contains the bytes having sequence numbers <code class="docutils literal notranslate"><span class="pre">12300</span></code> to <code class="docutils literal notranslate"><span class="pre">12320</span></code> while the original packet covered sequence numbers <code class="docutils literal notranslate"><span class="pre">12300</span></code> to <code class="docutils literal notranslate"><span class="pre">12325</span></code>. The NAT will thus need to adjust the sequence number of the subsquent packets sent by the client and also the acknowledgments returned by the server.</p>
<div class="figure" id="id80" style="text-align: center">
<span id="fig-mptcp-ip4tcp-ftp-port2"></span><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 63 </span><span class="caption-text">Packet carrying PORT command modified by the FTP ALG used by a NAT</span></p>
</div><p>As shown by the example above, an ALG can change bytes in the bytestream. It can also remove bytes from the bytestream and also add bytes in the bytestream. This happens notably when the ASCII representation of the public IP address of the NAT is longer than the private IP address of the internal host. This modification of the bytestream had a major impact on the design of Multipath TCP. It mainly affects the Data Sequence Number option that carries the data sequence numbers and acknowledgements. To detect modifications from ALGs and other middleboxes, this option covers a range of sequence numbers in the bytestream and includes an optional checksum that is computed by the Multipath TCP sender and checked by the receiver. If there is a mismatch between the checksum of the option and the data, the receiver stops using Multipath TCP and falls back to regular TCP to preserve the established connection. We discuss this fallback in more details later.</p>
<p>Our third type of middlebox that splits or coalesces TCP packets. This is not a router that performs IPv4 fragmentation or a host that splits a large IPv6 packets in fragments. In-network fragmentation is mainly disabled in IPv4 network since modern TCP stacks set the <code class="docutils literal notranslate"><span class="pre">DF</span></code> flag of the IP header. Those middleboxes do not reside in the middle of the network. They are typically included in the network adapter used by servers and even client hosts. Measurement studies have shown that hosts can reach higher throughputs when sending and receiving large packets. For example, a recent study <span id="id49">[<a class="reference internal" href="biblio.html#id8918" title="Mario Hock, Maxime Veit, Felix Neumeister, Roland Bless, and Martina Zitterbart. TCP at 100 Gbit/s–tuning, limitations, congestion control. In 2019 IEEE 44th Conference on Local Computer Networks (LCN), 1–9. IEEE, 2019.">68</a>]</span> reveals that over a 100 Gbps interface, a server was able to reach 25 Gbps with a single TCP connection using 1500 bytes packets. The same connection reached 40 Gbps by using jumbo frames, i.e. 9000 bytes packets. The jumbo frames are supported on modern Gigabit Ethernet networks but they are rarely used outside datacenters because most Internet paths still only supports 1500 bytes packets.</p>
<p>Modern network adapters support TCP Segmentation Offload (TSO) to improve the throughput of TCP connection are reduce the CPU load. In a nutshell, when TSO is enabled, the network adapter exposes a large maximum packet size, e.g. 16 KBytes to more, to the network stack. When the host sends such a large packet, it is automatically segmented in a sequence of small IP packets. On the receiver side, the network adapter performs the reverse operation. It coalesces small received packets into a larger one. <a class="reference internal" href="#fig-mptcp-tso"><span class="std std-numref">Fig. 64</span></a> shows a large (2 KBytes long) TCP packet. It is interesting to analyze how the key fields of this packet will be processed by TSO to segment it in the two smaller packets.</p>
<div class="figure" id="id81" style="text-align: center">
<span id="fig-mptcp-tso"></span><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 64 </span><span class="caption-text">A large IP packet containing TCP header and data</span></p>
</div><p>To segment the packet shown in <a class="reference internal" href="#fig-mptcp-tso"><span class="std std-numref">Fig. 64</span></a> in two smaller packets, TSO creates two <code class="docutils literal notranslate"><span class="pre">1040</span></code> bytes long IPv4 packets. The two small packets have a different IP Identification than the large one. TSO computes an IP checksum for each small packet. It then copies the TCP header of the large packet in both small ones, but with a fed adjustments. The sequence number of the  first small packet is the same as the large one. The sequence number of the sequence small packet is the one of the first packet increased by 1000.
Concerning the TCP options, TSO could analyze the contents of the option and handle each option in a specific manner. For example, TSO could adjust the TCP timestamp option of successive packets. In practice, measurements indicate that TSO simplies copies the TCP options field of the large packet in all small packets <span id="id50">[<a class="reference internal" href="biblio.html#id8928" title="Michio Honda, Yoshifumi Nishida, Costin Raiciu, Adam Greenhalgh, Mark Handley, and Hideyuki Tokuda. Is it still possible to extend TCP? In Proceedings of the 2011 ACM SIGCOMM Conference on Internet Measurement Conference, IMC '11, 181–194. New York, NY, USA, 2011. ACM. URL: http://doi.acm.org/10.1145/2068816.2068834, doi:10.1145/2068816.2068834.">69</a>]</span>. TSO places the first 1000 bytes of the payload of the large packet in the first small one and the last 1000 bytes in the second one. Finally, TSO needs to update the TCP checksum in all the small packets.</p>
<p>The receiver side of these network adapters implement Large Receive Offload (LRO). This basically coalesces the packets that were segmented by TSO. In this case, coalescing packets that carry different TCP options could be problematic since some of the TCP options would be lost in this process. Measurements with different TCP options show that LRO only coalesces packets that have exactly the same set of TCP implementations.</p>
<div class="figure" id="id82" style="text-align: center"><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 65 </span><span class="caption-text">The TCP header</span></p>
</div></div>
<div class="section" id="the-protocol-details">
<h2>The protocol details<a class="headerlink" href="#the-protocol-details" title="Permalink to this headline">¶</a></h2>
<div class="figure" id="id83" style="text-align: center"><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 66 </span><span class="caption-text">The MP_JOIN option in a SYN packet</span></p>
</div><div class="figure" id="id84" style="text-align: center"><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 67 </span><span class="caption-text">The MP_JOIN option in a SYN+ACK packet</span></p>
</div><div class="figure" id="id85" style="text-align: center"><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 68 </span><span class="caption-text">The MP_JOIN option in the initiator’s first ACK</span></p>
</div><div class="figure" id="id86" style="text-align: center"><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 69 </span><span class="caption-text">The Data Sequence Signal option</span></p>
</div><div class="figure" id="id87" style="text-align: center"><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 70 </span><span class="caption-text">The MP_PRIO option</span></p>
</div><div class="figure" id="id88" style="text-align: center"><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 71 </span><span class="caption-text">The ADD_ADDR option</span></p>
</div><div class="figure" id="id89" style="text-align: center"><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 72 </span><span class="caption-text">The REMOVE_ADDR option</span></p>
</div><div class="figure" id="id90" style="text-align: center"><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 73 </span><span class="caption-text">The MP_CAPABLE option in SYN packet</span></p>
</div><div class="figure" id="id91" style="text-align: center"><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 74 </span><span class="caption-text">The MP_CAPABLE option in SYN+ACK packet</span></p>
</div><div class="figure" id="id92" style="text-align: center"><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 75 </span><span class="caption-text">The MP_CAPABLE option in initiator’s first ACK (without data)</span></p>
</div><div class="figure" id="id93" style="text-align: center"><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 76 </span><span class="caption-text">The MP_CAPABLE option in initiator’s first ACK (with data)</span></p>
</div><div class="figure" id="id94" style="text-align: center"><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 77 </span><span class="caption-text">The MP_TCPRST option</span></p>
</div><div class="figure" id="id95" style="text-align: center"><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 78 </span><span class="caption-text">The FAST_CLOSE option</span></p>
</div></div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Modern Multipath Transport Protocols</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="usecases.html">Use cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="singlepath.html">Single path transport protocols</a></li>
<li class="toctree-l1"><a class="reference internal" href="quic.html">QUIC</a></li>
<li class="toctree-l1"><a class="reference internal" href="principles.html">Principles of multipath transport</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Multipath TCP</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#a-brief-overview-of-multipath-tcp">A brief overview of Multipath TCP</a></li>
<li class="toctree-l2"><a class="reference internal" href="#creating-a-multipath-tcp-connection">Creating a Multipath TCP connection</a></li>
<li class="toctree-l2"><a class="reference internal" href="#address-and-subflow-management">Address and subflow management</a></li>
<li class="toctree-l2"><a class="reference internal" href="#data-transfer">Data transfer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#congestion-control">Congestion control</a></li>
<li class="toctree-l2"><a class="reference internal" href="#connection-release">Connection release</a></li>
<li class="toctree-l2"><a class="reference internal" href="#coping-with-middlebox-interference">Coping with middlebox interference</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-protocol-details">The protocol details</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="mpquic.html">Multipath QUIC</a></li>
<li class="toctree-l1"><a class="reference internal" href="sctp.html">SCTP</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementations.html">Multipath TCP implementations</a></li>
<li class="toctree-l1"><a class="reference internal" href="comparison.html">Alternatives</a></li>
<li class="toctree-l1"><a class="reference internal" href="biblio.html">Bibliography</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="principles.html" title="previous chapter">Principles of multipath transport</a></li>
      <li>Next: <a href="mpquic.html" title="next chapter">Multipath QUIC</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Olivier Bonaventure.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.3.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/mptcp.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>