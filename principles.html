
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Principles of multipath transport &#8212; Modern Multipath Transport Protocols 2022 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="_static/plot_directive.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Multipath TCP" href="mptcp.html" />
    <link rel="prev" title="QUIC" href="quic.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="principles-of-multipath-transport">
<h1>Principles of multipath transport<a class="headerlink" href="#principles-of-multipath-transport" title="Permalink to this headline">¶</a></h1>
<div class="section" id="datagrams-and-streams">
<h2>Datagrams and Streams<a class="headerlink" href="#datagrams-and-streams" title="Permalink to this headline">¶</a></h2>
<p>Transport protocols are designed to provide a specific service to the application that uses them.</p>
<p>The simplest transport protocol is UDP <span id="id1">[<a class="reference internal" href="biblio.html#id704" title="J. Postel. User Datagram Protocol. RFC 768 (Internet Standard), August 1980. URL: https://www.rfc-editor.org/rfc/rfc768.txt, doi:10.17487/RFC0768.">2</a>]</span>. UDP enables applications to exchange datagrams. A datagram is a sequence of bytes that is sent as a message. In theory, applications should be able to send datagrams of up to 64 KBytes by leveraging IP’s fragmentation capabilities. In practice, most applications try to avoid IP fragmentation and only exchange datagrams that are smaller than the MTU of their underlying network, typically about 1500 bytes.</p>
<p>Applications can use UDP to send an isolated datagram or a series of datagrams. These datagrams can be sent without any prior exchange between the source and the destination applications. UDP does not guarantee that the sent datagrams will be delivered to their destination nor preserve ordering. UDP can detect transmission errors and discard the affected datagrams.</p>
<p>DCCP provides a different service to the applications. With DCCP, applications first open a connection and then use it to exchange sequences of datagrams. DCCP does not ensure a reliable delivery, but out-of-sequence datagrams can be reorder. Furthermore, DCCP includes congestion control schemes that rely on the measured round-trip-times and packet losses to adjust the transmission rate to the current network conditions.</p>
<p>TCP provides a reliable bytestream service to applications. The client must initiate a connection with a remote server to be able to exchange data. Once the connection is established, there is a bidirectional bytestream from the client to the server and another bytestream in the opposite direction. As long as the connection remains active, TCP ensures that the bytes pushed on the bytestream are delivered correctly and in-sequence to the distant peer. TCP also uses congestion and flow control to adjust the transmission rate to the current network conditions.</p>
<p>SCTP goes one step further than TCP by supporting multiple streams in both directions of a connection. SCTP is a message oriented protocol. The applications use SCTP to exchange messages that are composed of a variable number of bytes. SCTP applications can define several streams that are transported over a given association. Over a given stream, SCTP ensures that all messages are delivered in sequence. SCTP also supports unordered messages which can be delivered without waiting for other messages sent on the same stream. SCTP also uses congestion and flow control like TCP.</p>
</div>
<div class="section" id="middleboxes">
<h2>Middleboxes<a class="headerlink" href="#middleboxes" title="Permalink to this headline">¶</a></h2>
<p>IP networks contain a variety of devices. Besides the endhosts, networking students are familiar with the switches and access points that relay layer-2 frames and the routers that relay packets. <a class="reference internal" href="#fig-switches-routers"><span class="std std-numref">Fig. 30</span></a> illustrates a network with two hosts communicating through one switch and one router.</p>
<div class="figure" id="id26" style="text-align: center">
<span id="fig-switches-routers"></span><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 30 </span><span class="caption-text">Routers and switches in the reference model</span></p>
</div><p><span id="id2">Sherry <em>et al.</em> [<a class="reference internal" href="biblio.html#id8911" title="Justine Sherry, Shaddi Hasan, Colin Scott, Arvind Krishnamurthy, Sylvia Ratnasamy, and Vyas Sekar. Making middleboxes someone else's problem: network processing as a cloud service. ACM SIGCOMM Computer Communication Review, 42(4):13–24, 2012.">36</a>]</span> show that deployed networks contain a variety of devices besides the traditional layer-2 switches and the layer-3 routers <span id="id3">[<a class="reference internal" href="biblio.html#id8911" title="Justine Sherry, Shaddi Hasan, Colin Scott, Arvind Krishnamurthy, Sylvia Ratnasamy, and Vyas Sekar. Making middleboxes someone else's problem: network processing as a cloud service. ACM SIGCOMM Computer Communication Review, 42(4):13–24, 2012.">36</a>]</span>. These middleboxes include firewalls, Network Address Translators, transparent proxies, VPN gateways, network caches, … Each of these middleboxes processes the packets at different layers. From a reference model viewpoint, they can be depicted as shown in <a class="reference internal" href="#fig-middlebox"><span class="std std-numref">Fig. 31</span></a>.</p>
<div class="figure" id="id27" style="text-align: center">
<span id="fig-middlebox"></span><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 31 </span><span class="caption-text">Middleboxes in the reference model</span></p>
</div><p>A detailed review of the operation of all these middleboxes is outside the scope of this document. However, it is interesting to analyze in more details three representative middleboxes. Our first middleboxes are the firewalls. Several types of firewalls have been deployed. The simplest ones are stateless. They analyze several fields of the packets and decide, on a per-packet basis, which packets are forwarded and which packets are discarded. More advanced firewalls can track transport connections or application-level sessions and deal with out-of-order packets or retransmissions.</p>
<p>Stateless firewalls are often configured by network engineers with <cite>white lists</cite>, i.e. lists of destination addresses and ports of the services that are exposed outside the firewall. The packets that match one of these white lists are accepted while the others are rejected. These whitelists typically contain the list of the IP addresses of the public facing servers, the transport protocols they use (i.e. TCP or UDP) and the corresponding port numbers. Measurements indicate that there are unfortunately many Internet paths where other protocols than TCP, UDP and ICMP are simply blocked <span id="id4">[<a class="reference internal" href="biblio.html#id8912" title="Runa Barik, Michael Welzl, Gorry Fairhurst, Ahmed Elmokashfi, Thomas Dreibholz, and Stein Gjessing. On the usability of transport protocols other than tcp: a home gateway and internet path traversal study. Computer Networks, 173:107211, 2020.">17</a>]</span>. DCCP seems to be more often blocked than SCTP. Many of these firewalls simply filter packets based on the IPv4 protocol field or the IPv6 Next Header information. Unfortunately, the deployment of such firewalls ossifies the Internet by making it more difficult to deploy other protocols above IP than TCP, UDP and ICMP. Concerning UDP, <span id="id5">Barik <em>et al.</em> [<a class="reference internal" href="biblio.html#id8912" title="Runa Barik, Michael Welzl, Gorry Fairhurst, Ahmed Elmokashfi, Thomas Dreibholz, and Stein Gjessing. On the usability of transport protocols other than tcp: a home gateway and internet path traversal study. Computer Networks, 173:107211, 2020.">17</a>]</span> shows that UDP-Lite <span id="id6">[<a class="reference internal" href="biblio.html#id3746" title="L-A. Larzon, M. Degermark, S. Pink, L-E. Jonsson (Ed.), and G. Fairhurst (Ed.). The Lightweight User Datagram Protocol (UDP-Lite). RFC 3828 (Proposed Standard), July 2004. Updated by RFC 6335. URL: https://www.rfc-editor.org/rfc/rfc3828.txt, doi:10.17487/RFC3828.">37</a>]</span>, a small modification to UDP, is more often blocked on Internet paths than UDP.</p>
<dl class="simple">
<dt>Stateful firewalls go one step further and maintain state for the transport-level network flows passing through them. A stateful firewall can check that an ICMP message corresponds to an existing TCP connection. When it receives a TCP packet that carries data, it checks whether the packet belongs to an active connection. Otherwise the packet is dropped. Such a firewall can also verify that TCP packets are sent in sequence. It may discard packets that are severely out-of-sequence to protect servers from packet injection attacks. Some firewalls also verify the transport-level options carried by the connection establishment and the data packets. Some of them only support a limited number of options and discard or remove the options that they considered as unknown <span id="id7">[<a class="reference internal" href="biblio.html#id8913" title="Michio Honda, Yoshifumi Nishida, Costin Raiciu, Adam Greenhalgh, Mark Handley, and Hideyuki Tokuda. Is it still possible to extend tcp? In Proceedings of the 2011 ACM SIGCOMM conference on Internet measurement conference, 181–194. 2011.">38</a>]</span>. This behavior restricts the extensibility of transport protocols and the deployment of a new transport extension requires cooperation from three types of devices:</dt><dd><ul class="simple">
<li><p>the clients</p></li>
<li><p>the servers</p></li>
<li><p>the middleboxes that are present in the client and the server’s networks</p></li>
</ul>
</dd>
</dl>
<p><span id="id8">Fukuda [<a class="reference internal" href="biblio.html#id8914" title="Kensuke Fukuda. An analysis of longitudinal tcp passive measurements (short paper). In International Workshop on Traffic Monitoring and Analysis, 29–36. Springer, 2011.">39</a>]</span> analyzes packet traces collected on the Internet and reports the slow deployment of TCP options. In 2002, the TCP selective acknowledgments <span id="id9">[<a class="reference internal" href="biblio.html#id1948" title="M. Mathis, J. Mahdavi, S. Floyd, and A. Romanow. TCP Selective Acknowledgment Options. RFC 2018 (Proposed Standard), October 1996. URL: https://www.rfc-editor.org/rfc/rfc2018.txt, doi:10.17487/RFC2018.">13</a>]</span>, standardized in 1996, were only used by 10% of the observed connections in 2001. In 2010, this number grew to 90%. Unfortunately, the timestamps and large windows extensions <span id="id10">[<a class="reference internal" href="biblio.html#id1255" title="V. Jacobson, R. Braden, and D. Borman. TCP Extensions for High Performance. RFC 1323 (Proposed Standard), May 1992. Obsoleted by RFC 7323. URL: https://www.rfc-editor.org/rfc/rfc1323.txt, doi:10.17487/RFC1323.">22</a>]</span>, standardized in 1993, were only used by 60% of the connections in 2010. The main reason was that Microsoft Windows client did not implement these extensions. Nowadays, this popular TCP implementation supports large windows but still not the timestamps option.</p>
<p>Network Address Translators (NAT) <span id="id11">[<a class="reference internal" href="biblio.html#id2952" title="P. Srisuresh and K. Egevang. Traditional IP Network Address Translator (Traditional NAT). RFC 3022 (Informational), January 2001. URL: https://www.rfc-editor.org/rfc/rfc3022.txt, doi:10.17487/RFC3022.">40</a>]</span> are widely used in home and enterprise networks to reduce the utilization of scarce public IPv4 addresses. The hosts in the home/enterprise networks use private addresses. The packets that they send to the public Internet pass through a NAT that translates their IP addresses and ports. A NAT maps private addresses to one or more public IP addresses. Some NATs map each internal IP address to a public address. In this case, the NAT simply needs to change the source and destination addresses fields of the IP packets that it forwards. Note that for TCP and UDP it also needs to update the transport layer checksum since its computation also includes the source and destination IP addresses. Most NATs map multiple private addresses on a public one. In this case, they also need to change port numbers in the transport header. Some protocols such as the file transfer protocol (FTP) <span id="id12">[<a class="reference internal" href="biblio.html#id894" title="J. Postel and J. Reynolds. File Transfer Protocol. RFC 959 (Internet Standard), October 1985. Updated by RFCs 2228, 2640, 2773, 3659, 5797, 7151. URL: https://www.rfc-editor.org/rfc/rfc959.txt, doi:10.17487/RFC0959.">41</a>]</span> encode IP addresses in the application messages. To support such application layer protocols, NAT must include Application Level Gateways (ALGs) that translate these application messages. To perform this translation, these ALGs need to change, add or remove bytes in the transport bytestream.</p>
<p>Measurement studies performed in 2010 <span id="id13">[<a class="reference internal" href="biblio.html#id8908" title="Seppo Hätönen, Aki Nyrhinen, Lars Eggert, Stephen Strowes, Pasi Sarolahti, and Markku Kojo. An experimental study of home gateway characteristics. In Proceedings of the 10th ACM SIGCOMM conference on Internet measurement, 260–266. 2010.">26</a>]</span> showed that some deployed NATs do not support all standardized transport protocols and their recent extensions. Unfortunately, recent measurements <span id="id14">[<a class="reference internal" href="biblio.html#id8912" title="Runa Barik, Michael Welzl, Gorry Fairhurst, Ahmed Elmokashfi, Thomas Dreibholz, and Stein Gjessing. On the usability of transport protocols other than tcp: a home gateway and internet path traversal study. Computer Networks, 173:107211, 2020.">17</a>]</span> confirm that today’s NATs still limit the deployment of new transport protocols and the extensibility of widely deployed protocols. Many of these problems were anticipated by the IETF <span id="id15">[<a class="reference internal" href="biblio.html#id2957" title="M. Holdrege and P. Srisuresh. Protocol Complications with the IP Network Address Translator. RFC 3027 (Informational), January 2001. URL: https://www.rfc-editor.org/rfc/rfc3027.txt, doi:10.17487/RFC3027.">42</a>]</span>.</p>
<p>Another important class of middleboxes are the load-balancers. Several types of load-balancers exist. For this section, we focus on a simple load-balancer that is placed in front of a group of servers as illustrated in <a class="reference internal" href="#fig-load-balancer"><span class="std std-numref">Fig. 32</span></a>. The simplest design is a load-balancer that receives all packets from clients and servers. When a connection attempt arrives, the load-balancer selects one server (e.g. the less loaded one) and then forwards the packet and all the other packets of the connection to this specific server. If all packets exchanged by the client and the servers pass through the load-balancer, it could become a bottleneck. Some designs allow the servers to send back their replies directly to the client without passing through the load-balancers. With other designs, it becomes possible for the load-balancer to only see the first packets of each connection. With such designs, most of the packets exchanged by the clients and the servers bypass the load-balancer. We will discuss how multipath protocols enable some of these designs later in this document.</p>
<div class="figure" id="id28" style="text-align: center">
<span id="fig-load-balancer"></span><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 32 </span><span class="caption-text">Load-balancers</span></p>
</div><p>Surprisingly, the high-speed network adapters used mainly on servers, but also on some laptops, can also interfere with the transport protocols. Network adapters are more efficient when sending large than small packets. The main reason is that there is a fixed cost for the operating system to prepare the transmission of a packet. This cost is roughly independent of the size of the packet that needs to be transferred. On the other hand, given network constraints with IPv4 <span id="id16">[<a class="reference internal" href="biblio.html#id8909" title="Christopher A Kent and Jeffrey C Mogul. Fragmentation considered harmful. ACM SIGCOMM Computer Communication Review, 25(1):75–87, 1995.">43</a>]</span> and IPv6 <span id="id17">[<a class="reference internal" href="biblio.html#id8716" title="R. Bonica, F. Baker, G. Huston, R. Hinden, O. Troan, and F. Gont. IP Fragmentation Considered Fragile. RFC 8900 (Best Current Practice), September 2020. URL: https://www.rfc-editor.org/rfc/rfc8900.txt, doi:10.17487/RFC8900.">44</a>]</span>, hosts only send network packets that fit in Ethernet’s MTU size, i.e. 1500 bytes. To efficiently support such small packet size, high performance network adapters implement Segmentation Offload and Receive Offload. There are variants of these techniques that are specific to protocols such as TCP and UDP. TCP Segmentation Offload <span id="id18">[<a class="reference internal" href="biblio.html#id8910" title="Douglas Freimuth, Elbert C Hu, Jason D LaVoie, Ronald Mraz, Erich M Nahum, Prashant Pradhan, and John M Tracey. Server network scalability and tcp offload. In USENIX Annual Technical Conference, General Track, 209–222. 2005.">45</a>]</span> is widely used and can be described as follows. To encourage the TCP stack to use large packets, the network adapter exposes a large MTU, e.g. 16 KBytes. When the TCP stack passes a 16 KBytes packet containing a TCP segment, the adapter automatically segments it in packets that are not longer than 1500 bytes. To perform this segmentation, the adapter creates the IP and TCP headers that are required for each 1500 Bytes packet with the correct sequence numbers. It copies other fields such as the receive window and also the TCP options <span id="id19">[<a class="reference internal" href="biblio.html#id8913" title="Michio Honda, Yoshifumi Nishida, Costin Raiciu, Adam Greenhalgh, Mark Handley, and Hideyuki Tokuda. Is it still possible to extend tcp? In Proceedings of the 2011 ACM SIGCOMM conference on Internet measurement conference, 181–194. 2011.">38</a>]</span>. The adapter also computes the checksums required by each packet. The receiver side performs the opposite and gathers several 1500 bytes packets in a larger one that is passed to the TCP stack. Without these optimizations, servers would not be able to reach the multiple tens of Gbps that are achievable today.</p>
<div class="admonition-todo admonition" id="id20">
<p class="admonition-title">Todo</p>
<p>figure example TSO ?</p>
</div>
<p>Our last middlebox is the transparent proxy. Transparent proxies are deployed in enterprise or mobile networks for security or performance reasons. Some enterprise networks use transparent proxies on their firewalls to observe all the data exchanged over transport connections and detect any attack or leak of information. Some mobile network providers have deployed transparent proxies to improve the performance of transport protocols in the wireless network compared to the classical client stacks <span id="id21">[<a class="reference internal" href="biblio.html#id8915" title="Raffaele Zullo, Antonio Pescapé, Korian Edeline, and Benoit Donnet. Hic sunt proxies: unveiling proxy phenomena in mobile networks. In 2019 Network Traffic Measurement and Analysis Conference (TMA), 227–232. IEEE, 2019.">46</a>]</span>.</p>
<div class="figure" id="id29" style="text-align: center">
<span id="fig-transparent-proxy"></span><p><img  src="None" alt="Figure made with TikZ" /></p>
<p class="caption"><span class="caption-number">Fig. 33 </span><span class="caption-text">Transparent proxies in the reference mode</span></p>
</div><p>Transparent proxies usually support TCP. With a transparent proxy, TCP is not anymore an end-to-end protocol. It becomes and end-proxy-end protocol. When a client initiates a TCP connection, the <code class="docutils literal notranslate"><span class="pre">SYN</span></code> packet is intercepted by the proxy that transparently terminates the connection. There is one connection between the client and the proxy. The proxy then initiates a connection towards the server. All the data sent by the client is carried over the first connection and then sent over the second one towards the server.</p>
<p>From the application’s viewpoint, the connection continues to carry one bytestream in each direction. However, from a TCP viewpoint, this is different. If the client negotiates TCP extensions on the connection with the proxy, there is no guarantee that the proxy will negotiate the same extensions with the server. Furthermore, an extension supported by both the client and the server will only be used independently over the two proxied connections provided that the proxy also supports the extension. If we observe the TCP packets sent by the client and received by the server, we will extract the same bytestream. However, it is unlikely that the sequence and acknowledgment numbers will be preserved when they reach the server. Furthermore, the size of some packets might change as well as proxies can fragment and reassemble data.
Measurement studies have analyzed the deployed proxies in more details <span id="id22">[<a class="reference internal" href="biblio.html#id8913" title="Michio Honda, Yoshifumi Nishida, Costin Raiciu, Adam Greenhalgh, Mark Handley, and Hideyuki Tokuda. Is it still possible to extend tcp? In Proceedings of the 2011 ACM SIGCOMM conference on Internet measurement conference, 181–194. 2011.">38</a>, <a class="reference internal" href="biblio.html#id8915" title="Raffaele Zullo, Antonio Pescapé, Korian Edeline, and Benoit Donnet. Hic sunt proxies: unveiling proxy phenomena in mobile networks. In 2019 Network Traffic Measurement and Analysis Conference (TMA), 227–232. IEEE, 2019.">46</a>, <a class="reference internal" href="biblio.html#id8916" title="Xing Xu, Yurong Jiang, Tobias Flach, Ethan Katz-Bassett, David Choffnes, and Ramesh Govindan. Investigating transparent web proxies in cellular networks. In International Conference on Passive and Active Network Measurement, 262–276. Springer, 2015.">47</a>]</span>.</p>
<p>Although middleboxes are usually designed to improve network performance or provide additional services, they often interfere with transport protocols in various ways. Transport protocols such as TCP were designed according to the end-to-end principle <span id="id23">[<a class="reference internal" href="biblio.html#id8917" title="Jerome H Saltzer, David P Reed, and David D Clark. End-to-end arguments in system design. ACM Transactions on Computer Systems (TOCS), 2(4):277–288, 1984.">48</a>]</span>. When a client and a server are logically associated with a transport connection, they both maintain some state. In the early days, some of the information found in the client’s state (e.g. the IP addresses and port numbers or the sequence and acknowledgment numbers) was also contained in the server’s state. The protocol ensured that these states remained synchronized during the entire connection. Unfortunately, with middleboxes, this assumption is not valid anymore. For a protocol such as TCP, middleboxes preserve the bytestream <a class="footnote-reference brackets" href="#fbytestream" id="id24">1</a> ., but some middleboxes may interfere with all the fields of the packet headers and thus the connection’s state. This has a profound impact on the deployment of extensions to transport protocols in the Internet <span id="id25">[<a class="reference internal" href="biblio.html#id8913" title="Michio Honda, Yoshifumi Nishida, Costin Raiciu, Adam Greenhalgh, Mark Handley, and Hideyuki Tokuda. Is it still possible to extend tcp? In Proceedings of the 2011 ACM SIGCOMM conference on Internet measurement conference, 181–194. 2011.">38</a>]</span>.</p>
</div>
<div class="section" id="representing-packets">
<h2>Representing Packets<a class="headerlink" href="#representing-packets" title="Permalink to this headline">¶</a></h2>
<p>How to describe packets ? classical packet notation or QUIC notation ?</p>
<p>Transport protocols exchange control information and data produced by the applications that use them. Protocols such as UDP, DCCP and TCP use simple packet formats that are composed of two parts:</p>
<blockquote>
<div><ul class="simple">
<li><p>a (usually variable) length header carrying the control information such as port numbers, sequence numbers, acknowledgments, windows, …</p></li>
<li><p>a variable length payload carrying the data supplied by the application</p></li>
</ul>
</div></blockquote>
<p>The specifications for these protocols usually represents the different types of packets that they exchange using ASCII art. For example the format of the TCP header is usually described as shown in <a class="reference internal" href="#fig-tcp-header"><span class="std std-numref">Listing 18</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="id30">
<span id="fig-tcp-header"></span><div class="code-block-caption"><span class="caption-number">Listing 18 </span><span class="caption-text">Graphical representation of the TCP header</span><a class="headerlink" href="#id30" title="Permalink to this code">¶</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go"> 0                   1                   2                   3</span>
<span class="go"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span>
<span class="go">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="go">|          Source Port          |       Destination Port        |</span>
<span class="go">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="go">|                        Sequence Number                        |</span>
<span class="go">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="go">|                    Acknowledgment Number                      |</span>
<span class="go">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="go">|  Data |           |U|A|P|R|S|F|                               |</span>
<span class="go">| Offset| Reserved  |R|C|S|S|Y|I|            Window             |</span>
<span class="go">|       |           |G|K|H|T|N|N|                               |</span>
<span class="go">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="go">|           Checksum            |         Urgent Pointer        |</span>
<span class="go">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
</pre></div>
</div>
</div>
<p>This representation works well for protocols like TCP or UDP, but becomes cumbersome for security protocols such as TLS. More recent protocols such as QUIC have opted for a textual representation of the format of a packet.</p>
<div class="literal-block-wrapper docutils container" id="id31">
<span id="fig-tcp-header-text"></span><div class="code-block-caption"><span class="caption-number">Listing 19 </span><span class="caption-text">Textual representation of the TCP header</span><a class="headerlink" href="#id31" title="Permalink to this code">¶</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">TCP Header {</span>
<span class="go">  Source Port (16),</span>
<span class="go">  Destination Port (16),</span>
<span class="go">  Sequence Number (32),</span>
<span class="go">  Acknowledgment Number (32),</span>
<span class="go">  Data Offset (4),</span>
<span class="go">  Reserved (6),</span>
<span class="go">  URG (1),</span>
<span class="go">  ACK (1),</span>
<span class="go">  PSH (1),</span>
<span class="go">  RST (1),</span>
<span class="go">  SYN (1),</span>
<span class="go">  FIN (1),</span>
<span class="go">  Window (16),</span>
<span class="go">  Checksum (16),</span>
<span class="go">  Urgent Pointer (16)</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p class="rubric">Footnotes</p>
<dl class="footnote brackets">
<dt class="label" id="fbytestream"><span class="brackets"><a class="fn-backref" href="#id24">1</a></span></dt>
<dd><p>There are middleboxes that modify the bytestream, e.g. the Application Level Gateways used by NATs or some transparent web proxies.</p>
</dd>
</dl>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Modern Multipath Transport Protocols</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="usecases.html">Use cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="singlepath.html">Single path transport protocols</a></li>
<li class="toctree-l1"><a class="reference internal" href="quic.html">QUIC</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Principles of multipath transport</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#datagrams-and-streams">Datagrams and Streams</a></li>
<li class="toctree-l2"><a class="reference internal" href="#middleboxes">Middleboxes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#representing-packets">Representing Packets</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="mptcp.html">Multipath TCP</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpquic.html">Multipath QUIC</a></li>
<li class="toctree-l1"><a class="reference internal" href="sctp.html">SCTP</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementations.html">Multipath TCP implementations</a></li>
<li class="toctree-l1"><a class="reference internal" href="comparison.html">Alternatives</a></li>
<li class="toctree-l1"><a class="reference internal" href="biblio.html">Bibliography</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="quic.html" title="previous chapter">QUIC</a></li>
      <li>Next: <a href="mptcp.html" title="next chapter">Multipath TCP</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Olivier Bonaventure.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.3.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/principles.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>