
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>QUIC &#8212; Modern Multipath Transport Protocols 2021 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Principles of multipath transport" href="principles.html" />
    <link rel="prev" title="Single path transport protocols" href="singlepath.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="quic">
<h1>QUIC<a class="headerlink" href="#quic" title="Permalink to this headline">¶</a></h1>
<p>QUIC <span id="id1">[<a class="reference internal" href="biblio.html#id8812" title="J. Iyengar (Ed.) and M. Thomson (Ed.). QUIC: A UDP-Based Multiplexed and Secure Transport. RFC 9000 (Proposed Standard), May 2021. URL: https://www.rfc-editor.org/rfc/rfc9000.txt, doi:10.17487/RFC9000.">8</a>]</span> is the latest transport protocol standardized by the IETF. There are several characteristics that distinguish QUIC from other transport protocols:</p>
<blockquote>
<div><ul class="simple">
<li><p>QUIC supports multiple streams like SCTP</p></li>
<li><p>QUIC includes various reliability and congestion control mechanisms like TCP</p></li>
<li><p>QUIC directly integrates the security features of TLS 1.3 <span id="id2">[<a class="reference internal" href="biblio.html#id8271" title="E. Rescorla. The Transport Layer Security (TLS) Protocol Version 1.3. RFC 8446 (Proposed Standard), August 2018. URL: https://www.rfc-editor.org/rfc/rfc8446.txt, doi:10.17487/RFC8446.">6</a>]</span> instead of simply layering TLS above the transport layer</p></li>
<li><p>QUIC can also be used to carry datagrams <span id="id3">[<a class="reference internal" href="biblio.html#id8899" title="Tommy Pauly, Eric Kinnear, and David Schinazi. An Unreliable Datagram Extension to QUIC. Internet-Draft draft-ietf-quic-datagram-06, Internet Engineering Task Force, October 2021. Work in Progress. URL: https://datatracker.ietf.org/doc/html/draft-ietf-quic-datagram-06.">15</a>]</span></p></li>
<li><p>QUIC runs above UDP in contrast with other transport protocols such as TCP, SCTP or DCCP that run above IP</p></li>
</ul>
</div></blockquote>
<p>From a pure layering viewpoint, QUIC can be illustrated as shown in <a class="reference internal" href="#fig-quic-layers"><span class="std std-numref">Fig. 11</span></a>.</p>
<div class="figure" id="id28" style="text-align: center">
<span id="fig-quic-layers"></span><p><img  src="None" alt="Figure made with TikZ" /></p>
<p><span class="caption-number">Fig. 11 </span><span class="caption-text">QUIC in the TCP/IP stack</span></p>
</div><p>It is unusual to layer a transport protocol above another one. QUIC opted for this solution for two main reasons. First, on most operating systems, any application can directly use UDP without requiring special privileges. This implies that QUIC can be implemented as a library which can be included directly inside applications. This contrasts with TCP, SCTP or DCCP whose implementations are either part of the operating system kernel or need special privileges to send <cite>raw</cite> packets. The second motivation is that UDP (as well as TCP and ICMP) is supported by most middleboxes while many of them block transport protocols that were not defined when they were designed <span id="id4">[<a class="reference internal" href="biblio.html#id8907" title="Runa Barik, Michael Welzl, Gorry Fairhurst, Ahmed Elmokashfi, Thomas Dreibholz, and Stein Gjessing. On the usability of transport protocols other than tcp: a home gateway and internet path traversal study. Computer Networks, 173:107211, 2020.">16</a>]</span>.</p>
<p>It is useful to note that by using UDP, QUIC slightly increases its overhead. Each QUIC packet carries 8 bytes of headers containing the source and destination ports, the length field and a checksum. UDP also comes with a performance penalty. During the last decades, operating system kernels have been optimized to provide high bandwidth using TCP with techniques such as TCP Segmentation Offload (TSO) and Generic Receive Offload (GRO). In parallel, the UDP implementation has not changed significantly and most of the optimizations focused on request-response services such as DNS servers. The situation has changed recently with some effort, notably on Linux, to improve UDP’s raw throughput.</p>
<div class="admonition-todo admonition" id="id5">
<p class="admonition-title">Todo</p>
<p>add reference</p>
</div>
<section id="connection-establishment">
<h2>Connection establishment<a class="headerlink" href="#connection-establishment" title="Permalink to this headline">¶</a></h2>
<p>QUIC uses a four-way handshake to create a QUIC connection. <a class="reference internal" href="#fig-quic-handshake"><span class="std std-numref">Fig. 12</span></a> describes this handshake. This handshake has three main purposes. First, it allows to negotiate the crypto keys required to both encrypt and authenticate the packets that will be sent later on the connection. This is mainly done using TLS 1.3 <span id="id6">[<a class="reference internal" href="biblio.html#id8271" title="E. Rescorla. The Transport Layer Security (TLS) Protocol Version 1.3. RFC 8446 (Proposed Standard), August 2018. URL: https://www.rfc-editor.org/rfc/rfc8446.txt, doi:10.17487/RFC8446.">6</a>]</span>. Second, it allows to negotiate different transport parameters. Third, the server can validate that the client can respond to the address used to send the initial packet. This validation allows to prevent denial of service attacks using spoofed addresses.</p>
<div class="figure" id="id29" style="text-align: center">
<span id="fig-quic-handshake"></span><p><img  src="None" alt="Figure made with TikZ" /></p>
<p><span class="caption-number">Fig. 12 </span><span class="caption-text">Simplified QUIC Handshake</span></p>
</div><p>Before looking at the details of the negotiation of the cryptographic parameters, it is interesting to see how QUIC counters denial of service attacks that use spoofed addresses. During such attack, host <cite>x</cite> sends packets using the address of host <cite>y</cite> as their source. The main risk of such attacks is that the server could send a large number of packets towards address <cite>y</cite> although this address did not try to establish a QUIC connection with the server. QUIC prevents such attacks using two distinct techniques. First, and this is unusual for transport protocols, the Initial QUIC packet sent by the client is large. The first packet sent to create a QUIC connection must contain a UDP payload of at least 1200 bytes <span id="id7">[<a class="reference internal" href="biblio.html#id8812" title="J. Iyengar (Ed.) and M. Thomson (Ed.). QUIC: A UDP-Based Multiplexed and Secure Transport. RFC 9000 (Proposed Standard), May 2021. URL: https://www.rfc-editor.org/rfc/rfc9000.txt, doi:10.17487/RFC9000.">8</a>]</span>. Such a packet contains a CRYPTO frame has shown in the figure, but also padding frames to fill the packet. If an attacker wants to send spoofed packets to initiate a connection with a server, it needs to send more than one KByte for each connection attempt. By sending a large initial packet, the client can also perform Path MTU discovery and detect routers that could fragment the QUIC packets.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Address spoofing</p>
<p>Discuss a bit address spoofing, how frequent this is and how to mitigate that BCP38</p>
</div>
<p>The second mitigation against denial-of-service attacks using spoofed packets operates on the server. When a server receives an initial packet from a client, it may respond with an initial packet as shown in <a class="reference internal" href="#fig-quic-handshake"><span class="std std-numref">Fig. 12</span></a>. This could for example be the case of an enterprise server that receives a request from host of the same enterprise. The server could also want to validate the client and verify that the client can receive the packets that it sends. For this, it returns a Retry frame and a Token. This token is an opaque field that is constructed in a way that makes it easy for the server to validate the subsequent client packets and difficult for the client to predict the token that a server will create. A possible approach is to compute a secure hash of a message that contains the source IP addresses and ports used by the client, a secret value only known by the server and possibly some timing information to enable the server to ignore older tokens. Faced with the same problem, TCP using syn cookies that are encoded using fewer bits and thus inherently less secure. <a class="reference internal" href="#fig-quic-handshake-retry"><span class="std std-numref">Fig. 13</span></a> shows a QUIC handshake that includes a validation of the client address.</p>
<div class="figure" id="id30" style="text-align: center">
<span id="fig-quic-handshake-retry"></span><p><img  src="None" alt="Figure made with TikZ" /></p>
<p><span class="caption-number">Fig. 13 </span><span class="caption-text">Simplified QUIC Handshake with address validation</span></p>
</div><p>Address validation improves the resilience of servers against denial of service attacks using spoofed addresses, but this comes at the expense of a longer connection establishment delay. QUIC version 1 includes several additional techniques to reduce the impact of address validation while still preventing denial of service attacks.</p>
<section id="identifying-quic-connections">
<h3>Identifying QUIC connections<a class="headerlink" href="#identifying-quic-connections" title="Permalink to this headline">¶</a></h3>
<p>A TCP connection is identified by a four tuple <span class="math notranslate nohighlight">\(IP_{Client},IP_{Server},Port_{Client},Port_{Server}\)</span>. All packets belonging to a given connection carry this information in their IP and TCP headers. As QUIC runs above UDP, a simple approach could have been to use the UDP four tuple to identify each QUIC connection. Although simple, this solution would have severely restricted the flexibility of QUIC and the scalability of QUIC servers. The QUIC designers have opted for locally unique connection identifiers (CID) that are selected by the client and the server. These identifiers are placed in the QUIC packet headers during the handshake. When sending the Initial packet, the client selects a source CID that uniquely identifies the connection on the client and a random destination CID. Upon reception of this packet, the server selects its own connection identifier. It echoes the client selected CID and returns its selected CID. This is illustrated in <a class="reference internal" href="#fig-quic-handshake-cid"><span class="std std-numref">Fig. 14</span></a>.</p>
<div class="figure" id="id31" style="text-align: center">
<span id="fig-quic-handshake-cid"></span><p><img  src="None" alt="Figure made with TikZ" /></p>
<p><span class="caption-number">Fig. 14 </span><span class="caption-text">Connection identifiers during a simplified QUIC Handshake</span></p>
</div><p>The connection identifiers selected by the client and the server uniquely identify the QUIC connection. However, in contrast with TCP and UDP, the two identifiers are not present in all packets. Since a host selects a unique identifier for each connection, it only needs this identifier to identify a connection to which a packet belongs. For this reason, the QUIC packets exchanged on a connection after the handshake only contain the destination CID, i.e. the CID selected by the host that receives the packet.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Variable length CIDs</p>
<p>Most transport protocols rely on fixed-length fields because this simplifies the parsing of packet headers. For example, the TCP and UDP port numbers are encoded as as 16 bits field. However, using fixed-length fields also limits the extensibility of the protocol. A TCP server cannot listen to more than <span class="math notranslate nohighlight">\(2^{16}\)</span> different ports.</p>
<p>QUIC has opted for variable length CIDs to support very different use cases. On the server side, the length of the selected connection identifiers will depend on the architecture of the server. Large sites use a load-balancer that distributes the connections to different physical servers. They plan to read the CID on the load-balancer to direct the packet to the server that handles this connection. A simple CID would be composed of a server identifier chosen by the load balancer, e.g. in the high order bits of the CID, followed by a connection identifier selected by the physical server. Other designs are possible, e.g. by encrypting the CID to prevent attacks where malicious clients try to target a specific server.</p>
<p>One the client side, variable lengths CIDs bring another benefit. As clients typically manage a small number of QUIC connections, they can simply rely on the destination port of the packets that they receive to identify the corresponding QUIC connection. This corresponds to a zero-length connection identifier. Such a CID is never sent by the server after the handshake. This limits the byte overhead of the packets that clients receive.</p>
<p>A last point to note about these CIDs is their encoding inside the QUIC packets. The Initial packet contains the length and the value of both connection identifiers. The maximum length for a CID is 20 bytes. However, after the handshake, the packets that are exchanged over the QUIC connection only contain the destination CID without any field indicating its length. The host that has allocated the CID knows the length of the CIDs that it uses and can thus parse the packets that it receives.</p>
</div>
</section>
<section id="security-keys">
<h3>Security keys<a class="headerlink" href="#security-keys" title="Permalink to this headline">¶</a></h3>
<p>We can now discuss how QUIC leverages TLS 1.3 to negotiate the security keys that are used to authenticate and encrypt the packets exchanged over a connection. As shown in <a class="reference internal" href="#fig-quic-handshake"><span class="std std-numref">Fig. 12</span></a>, a QUIC connection starts with the exchange of four frames which can be carried in four or more packets. The first packet sent by the client contains the <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> TLS record. The <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> contains the information required to derive the session keys using Diffie-Hellman or a similar protocol. TLS 1.3 supports both finite field Diffie-Hellman and Elliptic Curve Diffie-Hellman <span id="id8">[<a class="reference internal" href="biblio.html#id8271" title="E. Rescorla. The Transport Layer Security (TLS) Protocol Version 1.3. RFC 8446 (Proposed Standard), August 2018. URL: https://www.rfc-editor.org/rfc/rfc8446.txt, doi:10.17487/RFC8446.">6</a>]</span>. The <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> message also contains TLS or QUIC parameters that the client proposes to use during the connection. The <code class="docutils literal notranslate"><span class="pre">ServerHello</span></code> returned by the server contains the certificate that enables the client to validate the server’s identity and the information required to determine the Diffie-Hellman keys. Using these keys, the server also encrypts the <code class="docutils literal notranslate"><span class="pre">EncryptedExtensions</span></code> message that contains the TLS and QUIC parameters that the server has selected based on the ones proposed in the <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code>. The server also constructs that <code class="docutils literal notranslate"><span class="pre">Finished</span></code> message that contains a message authentication code computed over the entire TLS handshake. This message is encrypted and authenticated using the session keys derived from the Diffie-Hellman keys. The client and the server recompute the hash of the entire handshake and verify both <code class="docutils literal notranslate"><span class="pre">Finished</span></code> message. If one of these messages is incorrect, this indicates that either the key has not been correctly derived or that some of the TLS messages have been tampered. In these situations, the QUIC connection is terminated with an error message. The simplified TLS handshake used by QUIC is illustrated in <a class="reference internal" href="#fig-quic-tls-handshake"><span class="std std-numref">Fig. 15</span></a>. The TLS messages shown in italics are encrypted using the session keys.</p>
<div class="figure" id="id32" style="text-align: center">
<span id="fig-quic-tls-handshake"></span><p><img  src="None" alt="Figure made with TikZ" /></p>
<p><span class="caption-number">Fig. 15 </span><span class="caption-text">Simplified TLS Handshake within a QUIC connection</span></p>
</div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Encrypting <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> and <code class="docutils literal notranslate"><span class="pre">ServerHello</span></code></p>
<p>When TLS 1.3 is used above TCP, the <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> and <code class="docutils literal notranslate"><span class="pre">ServerHello</span></code> messages are sent in clear because the client and the server have not yet exchanged the session keys. A similar approach could have been used for QUIC, but there was a fear that middleboxes could analyze the contents of these initial QUIC messages and try to interfere with them. To add some burden on such middleboxes, QUIC encrypts the Initial packets using a secret that is derived from the destination connection ID of the client’s first Initial packet. The pseudocode below, extracted from <span id="id9">[<a class="reference internal" href="biblio.html#id8813" title="M. Thomson (Ed.) and S. Turner (Ed.). Using TLS to Secure QUIC. RFC 9001 (Proposed Standard), May 2021. URL: https://www.rfc-editor.org/rfc/rfc9001.txt, doi:10.17487/RFC9001.">17</a>]</span>, shows how the client and the server keys are derived:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">initial_salt</span> <span class="o">=</span> <span class="mh">0x38762cf7f55934b34d179ae6a4c80cadccbb7f0a</span>
<span class="n">initial_secret</span> <span class="o">=</span> <span class="n">HKDF</span><span class="o">-</span><span class="n">Extract</span><span class="p">(</span><span class="n">initial_salt</span><span class="p">,</span>
                        <span class="n">client_dst_connection_id</span><span class="p">)</span>

<span class="n">client_initial_secret</span> <span class="o">=</span> <span class="n">HKDF</span><span class="o">-</span><span class="n">Expand</span><span class="o">-</span><span class="n">Label</span><span class="p">(</span><span class="n">initial_secret</span><span class="p">,</span>
             <span class="s2">&quot;client in&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">Hash</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
<span class="n">server_initial_secret</span> <span class="o">=</span> <span class="n">HKDF</span><span class="o">-</span><span class="n">Expand</span><span class="o">-</span><span class="n">Label</span><span class="p">(</span><span class="n">initial_secret</span><span class="p">,</span>
                           <span class="s2">&quot;server in&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span><span class="n">Hash</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
</pre></div>
</div>
<p>Since the keys used to protect the Initial packets are derived from the destination connection ID, any QUIC implementation, including those used on middleboxes, can decrypt the contents of the Initial packets.</p>
</div>
<p>As mentioned above, the client and the server can also use the TLS handshake to agree on specific QUIC parameters. These parameters are called <cite>transport parameters</cite> in <span id="id10">[<a class="reference internal" href="biblio.html#id8812" title="J. Iyengar (Ed.) and M. Thomson (Ed.). QUIC: A UDP-Based Multiplexed and Secure Transport. RFC 9000 (Proposed Standard), May 2021. URL: https://www.rfc-editor.org/rfc/rfc9000.txt, doi:10.17487/RFC9000.">8</a>]</span>. 17 different transport parameters are defined in <span id="id11">[<a class="reference internal" href="biblio.html#id8812" title="J. Iyengar (Ed.) and M. Thomson (Ed.). QUIC: A UDP-Based Multiplexed and Secure Transport. RFC 9000 (Proposed Standard), May 2021. URL: https://www.rfc-editor.org/rfc/rfc9000.txt, doi:10.17487/RFC9000.">8</a>]</span> and implementations can define their own transport parameters. We will discuss some of them in different sections of this document. A first example is the <code class="docutils literal notranslate"><span class="pre">max_udp_payload_size</span></code> parameter that indicates the largest UDP payload that an implementation is willing to receive. The minimum value for this parameter is 1200 bytes. QUIC implementations used in a datacenter could use a much larger <code class="docutils literal notranslate"><span class="pre">max_udp_payload_size</span></code> without risking packet fragmentation.</p>
<p>Another example of QUIC transport parameters are the <code class="docutils literal notranslate"><span class="pre">initial_source_connection_id</span></code> and the <code class="docutils literal notranslate"><span class="pre">original_destination_connection_id</span></code> transport parameters. As explained above, thanks to the <code class="docutils literal notranslate"><span class="pre">Finished</span></code> messages in the TLS handshake, the client and the servers can verify that their messages have not been tampered. Unfortunately, the authentication code included in the <code class="docutils literal notranslate"><span class="pre">Finished</span></code> messages is only computed based on the contents of the TLS messages (i.e. <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code>, <code class="docutils literal notranslate"><span class="pre">ServerHello</span></code>, <code class="docutils literal notranslate"><span class="pre">EncryptedExtensions</span></code> and <code class="docutils literal notranslate"><span class="pre">Finished</span></code>). During the handshake, the client and the servers also propose the source and destination connection identifiers that they plan to use to identify the QUIC session. These identifiers are placed in the packet header and not inside the TLS messages. They are thus not covered by the authentication code included in the <code class="docutils literal notranslate"><span class="pre">Finished</span></code> message. To still authenticate these identifiers, QUIC encodes them as transport parameters that are included in the <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> and the <code class="docutils literal notranslate"><span class="pre">EncryptedExtensions</span></code> messages. The client copies the source connection identifier in the <code class="docutils literal notranslate"><span class="pre">initial_source_connection_id</span></code> transport parameter in its <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code>. The server does the same when sending the <code class="docutils literal notranslate"><span class="pre">ServerHello</span></code>. It also copies in the <code class="docutils literal notranslate"><span class="pre">original_destination_connection_id</span></code> the destination identifier used by the client to send the packet containing the <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code>.</p>
</section>
<section id="the-quic-packet-headers">
<h3>The QUIC packet headers<a class="headerlink" href="#the-quic-packet-headers" title="Permalink to this headline">¶</a></h3>
<p>At this point, the QUIC session and the TLS security keys are known by the client and the server. They can start to exchange data. Before looking at how data is carried inside QUIC packets, it is interesting to explore in more details the packet headers that are placed inside each packet. QUIC uses variable length packet headers and two different header formats exist. The first header format is the long header. This is the header used for the first packets of a QUIC connection.</p>
<p><a class="reference internal" href="#fig-quic-long-header"><span class="std std-numref">Listing 1</span></a> shows the QUIC long header. It starts with one byte containing the header type in the most significant bit, two bits indicating the packet type and four bits that are specific to each packet packet. Then, 32 bits carry the QUIC version number. The current version of QUIC, defined in <span id="id12">[<a class="reference internal" href="biblio.html#id8812" title="J. Iyengar (Ed.) and M. Thomson (Ed.). QUIC: A UDP-Based Multiplexed and Secure Transport. RFC 9000 (Proposed Standard), May 2021. URL: https://www.rfc-editor.org/rfc/rfc9000.txt, doi:10.17487/RFC9000.">8</a>]</span>, corresponds to version <code class="docutils literal notranslate"><span class="pre">0x00000001</span></code>. The header then contains the destination and source connection identifiers that were described previously and then a payload that is specific to each type.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-long-header">
<div class="code-block-caption"><span class="caption-number">Listing 1 </span><span class="caption-text">The QUIC long header</span><a class="headerlink" href="#fig-quic-long-header" title="Permalink to this code">¶</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Long Header Packet {</span>
<span class="go">  Header Form (1) = 1,</span>
<span class="go">  Fixed Bit (1) = 1,</span>
<span class="go">  Long Packet Type (2),</span>
<span class="go">  Type-Specific Bits (4),</span>
<span class="go">  Version (32),</span>
<span class="go">  Destination Connection ID Length (8),</span>
<span class="go">  Destination Connection ID (0..160),</span>
<span class="go">  Source Connection ID Length (8),</span>
<span class="go">  Source Connection ID (0..160),</span>
<span class="go">  Type-Specific Payload (..),</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Encoding packet numbers</p>
<p>Most transport protocols use fixed fields to encode packet numbers or byte offsets. The size of this field is always a trade-off. On one hand, a small packet number field limits the per packet overhead. On the other hand, a large packet number space is required to ensure that two packets carrying different data don’t use the same packet number. TCP uses a 32 bits sequence number field that indicates the position of the first byte of the payload in the bytestream. This 32 bits field became a concern as bandwidth increased to Gbps and beyond. Modern TCP implementations use the timestamp option <span id="id13">[<a class="reference internal" href="biblio.html#id1255" title="V. Jacobson, R. Braden, and D. Borman. TCP Extensions for High Performance. RFC 1323 (Proposed Standard), May 1992. Obsoleted by RFC 7323. URL: https://www.rfc-editor.org/rfc/rfc1323.txt, doi:10.17487/RFC1323.">18</a>]</span> to enable a receiver to detect duplicates.</p>
<p>QUIC takes a different approach to sequence numbers. Each packet contains a per-packet sequence number. This number is encoded as a variable-length integer (<code class="docutils literal notranslate"><span class="pre">varint</span></code>). Such a <code class="docutils literal notranslate"><span class="pre">varint</span></code> has a length encoded in the two most significant bits of the first byte. If these bits are set to <code class="docutils literal notranslate"><span class="pre">00</span></code>, then the <code class="docutils literal notranslate"><span class="pre">varint</span></code> is encoded in one byte and can contain values between <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(2^{6}-1\)</span>.  If the two most significant bits are set to <code class="docutils literal notranslate"><span class="pre">01</span></code>, the <code class="docutils literal notranslate"><span class="pre">varint</span></code> can encode values <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(2^{14}-1\)</span> within two bytes. When the two high order bits are set to <code class="docutils literal notranslate"><span class="pre">11</span></code> the <code class="docutils literal notranslate"><span class="pre">varint</span></code> can encode values <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(2^{62}-1\)</span> within four bytes.</p>
<p>There are two order important between QUIC and other transport protocols when considering packet numbers. First, a QUIC sender can <em>never</em> reuse the same packet number for two different packets sent over a QUIC connection. If data needs to be retransmitted, it will be resent as a frame inside a new packet. Furthermore, since the largest possible packet number is <span class="math notranslate nohighlight">\(2^{62}-1\)</span>, a QUIC sender must close the corresponding connection once it has sent a QUIC packet carrying this packet number. This puts a restriction on the duration of QUIC connections. They cannot last forever in contrast to TCP connections such as those used to support BGP sessions between routers. An application that uses QUIC must be ready to restart a connection that has failed.</p>
</div>
<p>This long header is used for the <code class="docutils literal notranslate"><span class="pre">Initial</span></code>, <code class="docutils literal notranslate"><span class="pre">Handhsake</span></code> and <code class="docutils literal notranslate"><span class="pre">Retry</span></code> packets. Some of these packet types add new flags in the first byte and additional information after the connection identifiers. <a class="reference internal" href="#fig-quic-initial-header"><span class="std std-numref">Listing 2</span></a> shown the long header of the <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. It contains two bits in the first byte that indicate the length of the packet number field. The packet specific part contains an option token, a length field, a packet number and a payload. The token length, length and and packet number are encoded using variable length integers.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-initial-header">
<div class="code-block-caption"><span class="caption-number">Listing 2 </span><span class="caption-text">The QUIC long header of the Initial packet</span><a class="headerlink" href="#fig-quic-initial-header" title="Permalink to this code">¶</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Initial Packet {</span>
<span class="go">  Header Form (1) = 1,</span>
<span class="go">  Fixed Bit (1) = 1,</span>
<span class="go">  Long Packet Type (2) = 0,</span>
<span class="go">  Reserved Bits (2),</span>
<span class="go">  Packet Number Length (2),</span>
<span class="go">  Version (32),</span>
<span class="go">  Destination Connection ID Length (8),</span>
<span class="go">  Destination Connection ID (0..160),</span>
<span class="go">  Source Connection ID Length (8),</span>
<span class="go">  Source Connection ID (0..160),</span>
<span class="go">  Token Length (i),</span>
<span class="go">  Token (..),</span>
<span class="go">  Length (i),</span>
<span class="go">  Packet Number (8..32),</span>
<span class="go">  Packet Payload (8..),</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The QUIC short header contains fewer fields. The most significant bit of the first byte indicates that the packet carries a short header. The other flags will be discussed later. The two least significant bits of this byte contain the length of the packet number field. It is interesting to note that in contrast with the long header, there is no explicit indication of the length of the destination connection identifier. This connection identifier has been assigned by the host that receives this packet and it already knows the length of the connection identifiers that it uses.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-short-header">
<div class="code-block-caption"><span class="caption-number">Listing 3 </span><span class="caption-text">The QUIC short header used by 1-RTT packets</span><a class="headerlink" href="#fig-quic-short-header" title="Permalink to this code">¶</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">1-RTT Packet {</span>
<span class="go">   Header Form (1) = 0,</span>
<span class="go">   Fixed Bit (1) = 1,</span>
<span class="go">   Spin Bit (1),</span>
<span class="go">   Reserved Bits (2),</span>
<span class="go">   Key Phase (1),</span>
<span class="go">   Packet Number Length (2),</span>
<span class="go">   Destination Connection ID (0..160),</span>
<span class="go">   Packet Number (8..32),</span>
<span class="go">   Packet Payload (8..),</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The short header format depicted in <a class="reference internal" href="#fig-quic-short-header"><span class="std std-numref">Listing 3</span></a> is used by all QUIC packets once the session keys have been derived. This usually happens after one round-trip-time. They packets are called the 1-RTT packets in the QUIC specification. This notation is used to emphasize the fact that QUIC also supports 0-RTT packets, i.e. packets that carry data and can be exchanged in parallel with the TLS handshake.</p>
</section>
<section id="rtt-data">
<h3>0-RTT data<a class="headerlink" href="#rtt-data" title="Permalink to this headline">¶</a></h3>
<p>Latency is a key concern for transport protocols. The QUIC/TLS handshake that we have described until now allows the client and the server to agree on security keys within one round-trip-time. However, one round-trip-time can be a long delay for some applications. To minimize the impact of the connection setup time, QUIC allows applications to exchange data during the QUIC/TLS handshake. This data is called the 0-RTT data. To ensure that 0-RTT data is exchanged securely, the client and the server must have previously agreed on a key which can be used to encrypt and authenticate the 0-RTT data. Such a 0-RTT key could either be a pre-shared key that the client and the server have shared without using the QUIC protocol or, and this is the most frequent solution, the key that they negotiated during a previous connection. In practice, the server enables 0-RTT by sending a session ticket to the client. This session ticket is an encrypted record that contains information that enables the server to recover information about the session such as its session keys. It is also linked to the client’s address to enable the server to verify that a given client reuses the tickets that it has received earlier. Usually, these tickets also contain an expiration date. The client places the received ticket and the encrypted data in a 0-RTT packet. The server decrypts the information contained in the ticket to recover the session key and decrypt the data. <a class="reference internal" href="#fig-quic-0-rtt-packet"><span class="std std-numref">Listing 4</span></a> shows the format of QUIC’s 0-RTT packet.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-0-rtt-packet">
<div class="code-block-caption"><span class="caption-number">Listing 4 </span><span class="caption-text">The QUIC 0-RTT packet</span><a class="headerlink" href="#fig-quic-0-rtt-packet" title="Permalink to this code">¶</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">0-RTT Packet {</span>
<span class="go">  Header Form (1) = 1,</span>
<span class="go">  Fixed Bit (1) = 1,</span>
<span class="go">  Long Packet Type (2) = 1,</span>
<span class="go">  Reserved Bits (2),</span>
<span class="go">  Packet Number Length (2),</span>
<span class="go">  Version (32),</span>
<span class="go">  Destination Connection ID Length (8),</span>
<span class="go">  Destination Connection ID (0..160),</span>
<span class="go">  Source Connection ID Length (8),</span>
<span class="go">  Source Connection ID (0..160),</span>
<span class="go">  Length (i),</span>
<span class="go">  Packet Number (8..32),</span>
<span class="go">  Packet Payload (8..),</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Replay attacks and 0-RTT packets</p>
<p>Thanks to the 0-RTT packets, the client can send encrypted data to the server before waiting for the secure handshake. This reduces the latency of the data transfer, but with one important caveat. QUIC does not provide any guarantee that 0-RTT data will not be replayed. QUIC’s 0-RTT data exchanged is intended for idempotent operations. A detailed discussion of the impact of replay attacks may be found in <span id="id14">[<a class="reference internal" href="biblio.html#id8900" title="C. MacCarthaigh. Security review of TLS1.3 0-RTT. https://github.com/tlswg/tls13-spec/issues/1001.">19</a>]</span>.</p>
<p>To understand the importance of these replay attacks, let us consider a simple HTTP GET request. Such a request could easily fit inside the 0-RTT packet and thus have lower latency. If a web browser uses it to request a static <code class="docutils literal notranslate"><span class="pre">index.html</span></code> file, there is no harm if the request is received twice by the server. However, if the GET request is part of a REST API and has side effects, then problems could occur depending on the type of side effect. Consider a REST API that allows a user to switch off the lights using his or her smartphone. Replaying this request two or three times will always result in the light being switched off. However, if the user request to increase the room temperature by one °C, then multiple replays will obviously have inconvenient consequences.</p>
</div>
</section>
</section>
<section id="closing-a-quic-connection">
<h2>Closing a QUIC connection<a class="headerlink" href="#closing-a-quic-connection" title="Permalink to this headline">¶</a></h2>
<p>Before exploring how data can be exchanged over a QUIC connection, let us now analyze how the connection can terminate. QUIC supports three different methods to close a QUIC connection. QUIC’s approach to terminating connection is very different from the solutions used by traditional transport protocol.</p>
<p>QUIC runs above UDP and the design of QUIC was heavily influenced by the presence of NATs. NATs, like other middleboxes, maintain per-flow state. For TCP connections, many NATs rely on the <code class="docutils literal notranslate"><span class="pre">SYN</span></code>, <code class="docutils literal notranslate"><span class="pre">FIN</span></code> and <code class="docutils literal notranslate"><span class="pre">RST</span></code> flags to determine when state must be created or removed for a TCP connection. For UDP, this stateful approach is not possible and NATs create a new mapping when they observe the first packet of a flow and remove the mapping once the flow has been idle for sometime. The IETF recommends to maintain NAT mappings during at least two minutes <span id="id15">[<a class="reference internal" href="biblio.html#id4680" title="F. Audet (Ed.) and C. Jennings. Network Address Translation (NAT) Behavioral Requirements for Unicast UDP. RFC 4787 (Best Current Practice), January 2007. Updated by RFCs 6888, 7857. URL: https://www.rfc-editor.org/rfc/rfc4787.txt, doi:10.17487/RFC4787.">20</a>]</span>, but measurements show that deployed NATs use shorter timeouts <span id="id16">[<a class="reference internal" href="biblio.html#id8902" title="Philipp Richter, Florian Wohlfart, Narseo Vallina-Rodriguez, Mark Allman, Randy Bush, Anja Feldmann, Christian Kreibich, Nicholas Weaver, and Vern Paxson. A multi-perspective analysis of carrier-grade nat deployment. In Proceedings of the 2016 Internet Measurement Conference, 215–229. 2016.">21</a>, <a class="reference internal" href="biblio.html#id8903" title="Seppo Hätönen, Aki Nyrhinen, Lars Eggert, Stephen Strowes, Pasi Sarolahti, and Markku Kojo. An experimental study of home gateway characteristics. In Proceedings of the 10th ACM SIGCOMM conference on Internet measurement, 260–266. 2010.">22</a>]</span>. In practice, UDP flows should probably send a packet every 30 seconds to ensure that the on-path NATs preserve their state.</p>
<p>To prevent NATs from changing the mapping associated to the IP addresses and ports used for a QUIC connection, QUIC hosts will need to regularly send data over each established QUIC connection. QUIC defines a <code class="docutils literal notranslate"><span class="pre">PING</span></code> frame that allows any QUIC endpoint to send a frame that will trigger a response from the other peer. The <code class="docutils literal notranslate"><span class="pre">PING</span></code> frame does not carry data, but the receiver of a <code class="docutils literal notranslate"><span class="pre">PING</span></code> frame needs to acknowledge the packet containing this frame. This creates a bidirectional communication and can prevent NATs from discarding the mapping associated to the QUIC connection.</p>
<p>Each QUIC implementation keeps in the connection state the timestamp of the last QUIC packet received over this connection. During the connection establishment, the QUIC hosts can also exchange the <code class="docutils literal notranslate"><span class="pre">max_idle_timeout</span></code> parameter that indicates how long (in seconds) a QUIC connection can remain idle before being automatically closed. The first way to close a QUIC connection is make idle for this period of time.</p>
<p>The second technique to terminate a QUIC connection is to use the <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame. This frame indicates that this connection has been closed abruptly.  The host that receives the <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> may respond with one <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame. After that, it must stop sending any additional frame. It keeps the connection state for some time, but does not accept any new packet nor retransmit others. The host that sends a <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame indicates that it will neither send nor accept more data. It keeps a subset of the QUIC connection state to be able to retransmit the <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame if needed.</p>
<p>A host also sends a <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame to abruptly terminate a connection if it receives an invalid frame or detects a protocol error. In this case, the <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame contains a variable length integer that indicates the reason for the termination, the type of the frame that triggered the error and additional information encoded as a text string.</p>
<p>The QUIC specification also defines a third technique called <cite>stateless reset</cite> to cope with hosts that have lost connection state after a crash or outage. It relies on 16 bytes stateless token announced together with the connection identifier. See <span id="id17">[<a class="reference internal" href="biblio.html#id8812" title="J. Iyengar (Ed.) and M. Thomson (Ed.). QUIC: A UDP-Based Multiplexed and Secure Transport. RFC 9000 (Proposed Standard), May 2021. URL: https://www.rfc-editor.org/rfc/rfc9000.txt, doi:10.17487/RFC9000.">8</a>]</span> for all the details.</p>
</section>
<section id="exchanging-data-over-a-quic-connection">
<h2>Exchanging data over a QUIC connection<a class="headerlink" href="#exchanging-data-over-a-quic-connection" title="Permalink to this headline">¶</a></h2>
<p>The data exchanged over is QUIC connection is organized in different streams. A stream is a sequence of bytes. QUIC supports both unidirectional and bidirectional streams. Both the client and the server can create new streams over a QUIC connection. Each stream is identified by a stream identifier. To prevent problems when the client and the server try to create a stream using the same identifier, QUIC restricts the utilization of the stream identifiers based its two low-order bits. A QUIC client can only create streams whose two low order bits are set to <code class="docutils literal notranslate"><span class="pre">00</span></code> (bidirectional stream) or <code class="docutils literal notranslate"><span class="pre">10</span></code> (unidirectional stream). Similarly, the low order bits of the server-initiated streams must be set to <code class="docutils literal notranslate"><span class="pre">01</span></code> (bidirectional stream) or <code class="docutils literal notranslate"><span class="pre">11</span></code> (unidirectional streams). The QUIC streams are created implicitly by sending data over the stream with the chosen identifier. The stream identifiers start at the minimum value, i.e. <code class="docutils literal notranslate"><span class="pre">0x00</span></code> to <code class="docutils literal notranslate"><span class="pre">0x03</span></code> for the respective types. If a host sends stream data for stream <code class="docutils literal notranslate"><span class="pre">x</span></code> before having sent data over the lower-numbered streams of that type, then those streams are implicitly created. The stream identifier is encoded using a variable length integer. The largest possible stream identifier is thus <span class="math notranslate nohighlight">\(2^{62}-1\)</span>.</p>
<p>QUIC places all data inside <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frames that are then placed inside QUIC packets. The structure of a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame is shown in <a class="reference internal" href="#fig-quic-stream-frame"><span class="std std-numref">Listing 5</span></a>. This frame contains the following information :</p>
<blockquote>
<div><ul class="simple">
<li><p>the Type of the Stream frame <a class="footnote-reference brackets" href="#f-stream-type" id="id18">1</a></p></li>
<li><p>the identifier of the stream</p></li>
<li><p>the offset, i.e. the position of the first byte of the Stream data in the bytestream</p></li>
<li><p>the length of the data</p></li>
<li><p>the Stream Data</p></li>
</ul>
</div></blockquote>
<div class="literal-block-wrapper docutils container" id="fig-quic-stream-frame">
<div class="code-block-caption"><span class="caption-number">Listing 5 </span><span class="caption-text">The QUIC STREAM frame</span><a class="headerlink" href="#fig-quic-stream-frame" title="Permalink to this code">¶</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">STREAM Frame {</span>
<span class="go">   Type (i) = 0x0e..0x0f,</span>
<span class="go">   Stream ID (i),</span>
<span class="go">   Offset (i),</span>
<span class="go">   Length (i),</span>
<span class="go">   Stream Data (..),</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame carries data, but it can also terminate the corresponding stream. The lowest order bit of the Type field acts as a <code class="docutils literal notranslate"><span class="pre">FIN`</span></code> bit. When set to zero, it indicates that subsequent data will be sent over this stream. When set to one, it indicates that the <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame contains the last bytes sent over that stream. The stream is closed once the last byte of the stream has been delivered to the user application. Once a QUIC stream has been closed, it cannot be reused again over this connection.</p>
<p>Using this information, the receiver can easily reassemble the data received over the different streams. As an illustration, let us consider an application that a server has created two streams (stream <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">5</span></code>). The server sends <code class="docutils literal notranslate"><span class="pre">ABCD..</span></code> over stream <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">123</span></code> over stream <code class="docutils literal notranslate"><span class="pre">5</span></code> and closes it after the third digit. The data from these streams could be encoded as shown in <a class="reference internal" href="#fig-quic-streams-example"><span class="std std-numref">Listing 6</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-streams-example">
<div class="code-block-caption"><span class="caption-number">Listing 6 </span><span class="caption-text">Data sent over two different streams</span><a class="headerlink" href="#fig-quic-streams-example" title="Permalink to this code">¶</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">STREAM Frame {</span>
<span class="go">   Type (i) = 0x0e,</span>
<span class="go">   Stream ID = 1,</span>
<span class="go">   Offset = 0</span>
<span class="go">   Length = 2</span>
<span class="go">   Stream Data = AB</span>
<span class="go">}</span>
<span class="go">STREAM Frame {</span>
<span class="go">   Type (i) = 0x0e,</span>
<span class="go">   Stream ID = 5,</span>
<span class="go">   Offset = 0</span>
<span class="go">   Length = 1</span>
<span class="go">   Stream Data = 1</span>
<span class="go">}</span>
<span class="go">STREAM Frame {</span>
<span class="go">   Type (i) = 0x0e,</span>
<span class="go">   Stream ID = 1,</span>
<span class="go">   Offset = 2</span>
<span class="go">   Length = 1</span>
<span class="go">   Stream Data = C</span>
<span class="go">}</span>
<span class="go">STREAM Frame {</span>
<span class="go">   Type (i) = 0x0f,</span>
<span class="go">   Stream ID = 5,</span>
<span class="go">   Offset = 1</span>
<span class="go">   Length = 2</span>
<span class="go">   Stream Data = 23</span>
<span class="go">}</span>
<span class="go">STREAM Frame {</span>
<span class="go">   Type (i) = 0x0e,</span>
<span class="go">   Stream ID = 1,</span>
<span class="go">   Offset = 3</span>
<span class="go">   Length = 4</span>
<span class="go">   Stream Data = DEFG</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The penultimate frame shown in <a class="reference internal" href="#fig-quic-streams-example"><span class="std std-numref">Listing 6</span></a> has the <code class="docutils literal notranslate"><span class="pre">FIN</span></code> flag set. It marks the end of stream <code class="docutils literal notranslate"><span class="pre">1</span></code> that has transport three bytes in total. The <code class="docutils literal notranslate"><span class="pre">FIN</span></code> flag is the normal way to gracefully close a QUIC stream. There are however cases where an application might need to cancel a stream abruptly without closing the connection. First, the sending side of a stream can decide to reset the stream. For this, it sends a <code class="docutils literal notranslate"><span class="pre">RESET_STREAM</span></code> frame that indicates the identifier of the stream that is canceled. The receiving side of a stream might also need to stop receiving data over a given stream. Consider for example a web browser that has started to download the different images that compose a web while the user has already clicked on another page from the same server. The streams that corresponds to these images become useless. In this case, our browser can send a <code class="docutils literal notranslate"><span class="pre">STOP_SENDING</span></code> frame to indicate that it discards the incoming data over the corresponding streams. Upon reception of this frame, the server sends a <code class="docutils literal notranslate"><span class="pre">RESET_STREAM</span></code> frame to indicate that the corresponding stream has been closed.</p>
<section id="flow-control-in-quic">
<h3>Flow control in QUIC<a class="headerlink" href="#flow-control-in-quic" title="Permalink to this headline">¶</a></h3>
<p>Transport protocols usually allocate some resources to each established connection. Each QUIC connection requires memory to store its state, but also buffers to store the packets arrived out-of-order. In practice, the memory available for QUIC implementations is not unlimited and a QUIC receiver must control the amount of packets that the remote host can send at any time. QUIC supports flow control techniques that operate at different level.</p>
<p>The first level is the connection level.
During the handshake, each host can announce the maximum number of bytes that it agrees to receive initially on the connection using the <code class="docutils literal notranslate"><span class="pre">initial_max_data</span></code> transport parameter. This parameter contains the number of bytes that the sending host agrees to receive without further notice. If the connection uses more bytes than initially agreed, the receiver can update this limit by sending a <code class="docutils literal notranslate"><span class="pre">MAX_DATA</span></code> frame at any time. This frame contains a variable length integer that encodes the maximum amount of stream data that can be sent over the connection.</p>
<p>The utilization of different streams also consume resources on a QUIC host. A receiver can also restrict the number of streams that the remote host can create. During the handshake, the <code class="docutils literal notranslate"><span class="pre">initial_max_streams_bidi</span></code> and <code class="docutils literal notranslate"><span class="pre">initial_max_streams_uni</span></code> contain the maximum number of bidirectional and unidirectional streams that the receiving host can host. This limit can be modified during the connection by sending a <code class="docutils literal notranslate"><span class="pre">MAX_STREAMS</span></code> frame that updates the limit.</p>
<p>Flow control can also take place at the stream level. During the handshake, several transport parameters allow the hosts to advertise the maximum number of bytes that they agree to receive on each stream. Different transport parameters are used to specify the limits that apply to the local/remote and unidirectional/bidirectional streams. These limits can be updated during the connection by sending <code class="docutils literal notranslate"><span class="pre">MAX_STREAM_DATA</span></code> frames. Each of these frames indicates the maximum amount of stream data that can be accepted on a given stream.</p>
<p>These limits restricts the number of streams that a host can create and the amount of bytes that it can send. If a host is blocked by any of these limits, it may sent a control frame to request the remote host to extend the limit. For each type of flow control, there is an associated control frame which can be used to request an extension of the limit.</p>
<p>A host should send a <code class="docutils literal notranslate"><span class="pre">DATA_BLOCKED</span></code> frame when it reaches the limit on the maximum amount of data set by the <code class="docutils literal notranslate"><span class="pre">initial_max_data</span></code> transport parameter or a previously received <code class="docutils literal notranslate"><span class="pre">MAX_DATA</span></code> frame. The <code class="docutils literal notranslate"><span class="pre">DATA_BLOCKED</span></code> frame contains the connection limit that caused the transmission to be blocked. In practice, a receiving host should increase the connection-level limit by sending <code class="docutils literal notranslate"><span class="pre">MAX_DATA</span></code> frames before reaching the limit. However, since this limit is function of the available memory, a host might not always be able to send a <code class="docutils literal notranslate"><span class="pre">MAX_DATA</span></code> frame. <a class="reference internal" href="#fig-quic-example-max-data"><span class="std std-numref">Fig. 16</span></a> provides an example packet flow with the utilization of these frames.</p>
<div class="figure" id="id33" style="text-align: center">
<span id="fig-quic-example-max-data"></span><p><img  src="None" alt="Figure made with TikZ" /></p>
<p><span class="caption-number">Fig. 16 </span><span class="caption-text">QUIC use <code class="docutils literal notranslate"><span class="pre">MAX_DATA</span></code> frames when a connection’s flow control is blocked</span></p>
</div><p>The same applies with the <code class="docutils literal notranslate"><span class="pre">STREAM_DATA_BLOCKED</span></code> frame that is sent when a host reaching the per-stream limit. The <code class="docutils literal notranslate"><span class="pre">STREAMS_BLOCKED</span></code> frame is used when a host has reached the maximum number of established streams.</p>
</section>
<section id="quic-loss-detection">
<h3>QUIC Loss Detection<a class="headerlink" href="#quic-loss-detection" title="Permalink to this headline">¶</a></h3>
<p>As other transport protocols, QUIC includes mechanisms to detect transmission errors and losses. The transmission errors can be detected at two different levels. First, the UDP header contains a checksum that allows to detect various transmission errors. Second, since QUIC used AEAD encryption schemes, all QUIC packets are authenticated and a receiver can easily detect transmission errors when the AEAD tag does not validate. In these two cases, the corresponding UDP packet is discarded by the receiver.</p>
<p>There are several important differences between the loss detection and retransmission mechanisms used by QUIC and other transport protocols. First, QUIC packet numbers always increase monotonically over a QUIC connection. A QUIC sender never sends twice a packet with the same packet number over a given connection. QUIC encodes the packet numbers as variable length integers and it does not support wrap around in contrast with other transport protocols. The QUIC frames contain the valuable information that needs to be delivered reliably. If a QUIC packet is lost, the frames that it contained will be retransmitted in another QUIC packet that uses a different packet number. Thus, the QUIC packet number serves as a unique identifier of a packet. This simplifies some operations such as measuring the round-trip-time which is more difficult in protocols such as TCP when packets are transmitted <span id="id19">[<a class="reference internal" href="biblio.html#id8901" title="Phil Karn and Craig Partridge. Improving round-trip time estimates in reliable transport protocols. ACM SIGCOMM Computer Communication Review, 17(5):2–7, 1987.">23</a>]</span>.</p>
<p>Second, QUIC’s acknowledgments carry more information than the cumulative or selective acknowledgments used by TCP and related protocols. This enables the receiver to provide a more detailed view of the packets that it received. In contrast with TCP <span id="id20">[<a class="reference internal" href="biblio.html#id1948" title="M. Mathis, J. Mahdavi, S. Floyd, and A. Romanow. TCP Selective Acknowledgment Options. RFC 2018 (Proposed Standard), October 1996. URL: https://www.rfc-editor.org/rfc/rfc2018.txt, doi:10.17487/RFC2018.">12</a>]</span>, once a receiver has reported that one packet was correctly received in an acknowledgment, the sender of that packet can discard the corresponding frames.</p>
<p>Third, a QUIC sender autonomously decides which frames it sends inside each packet. A QUIC packet may contain both data and control frames, or only data or only control information. If a QUIC packet is lost, the frames that it contained could be retransmitted in different packets. A QUIC implementation thus needs to buffer the frames and mark the in-flight ones to be able to retransmit them if the corresponding packet was lost.</p>
<p>Fourth, most QUIC packets are explicitly acknowledged. The only exception are the packets that only contain <code class="docutils literal notranslate"><span class="pre">ACK</span></code>, <code class="docutils literal notranslate"><span class="pre">PADDING</span></code> or <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code>. A packet that contains any other QUIC frame is called an ack-eliciting packet because its delivery will be confirmed by the transmission of an acknowledgment. A QUIC packet that carries both an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> and a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame will thus be acknowledged.</p>
<p>With this in mind, it is interesting to look at the format of the QUIC acknowledgments and then analyze how they can be used. <a class="reference internal" href="#fig-quic-ack-frame"><span class="std std-numref">Listing 7</span></a> provides the format of an ACK frame. It can be sent at any time in a QUIC packet. Two types are used to distinguish between the acknowledgments that contain information about the received ECN flags (type <code class="docutils literal notranslate"><span class="pre">0x03</span></code>) or only regular acknowledgments (type <code class="docutils literal notranslate"><span class="pre">0x02</span></code>). The first information contained in the ACK frame is the largest packet number that is acknowledged by this ACK frame. This is usually the highest packet number received. The second information is the ACK delay. This is the delay in microseconds between the reception of the packet having the largest acknowledged number by the receiver and the transmission of the acknowledgments. This information is important to ensure that round-trip-times are accurately measured, even if a receiver delays acknowledgments. This is illustrated in <a class="reference internal" href="#fig-quic-ack-delay"><span class="std std-numref">Fig. 17</span></a>. The <code class="docutils literal notranslate"><span class="pre">ACK</span> <span class="pre">Range</span> <span class="pre">Count</span></code> contains the number of <code class="docutils literal notranslate"><span class="pre">ACK</span> <span class="pre">ranges</span></code> that are included in the QUIC ACK frame. This number can be set to zero if all packets were received in sequence without any gap. In this case, the <code class="docutils literal notranslate"><span class="pre">First</span> <span class="pre">ACK</span> <span class="pre">Range</span></code> field contains the number of packets that arrived before the <code class="docutils literal notranslate"><span class="pre">Largest</span> <span class="pre">Acknowledged</span></code> packet number.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-ack-frame">
<div class="code-block-caption"><span class="caption-number">Listing 7 </span><span class="caption-text">The QUIC ACK Frame</span><a class="headerlink" href="#fig-quic-ack-frame" title="Permalink to this code">¶</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">ACK Frame {</span>
<span class="go">   Type (i) = 0x02..0x03,</span>
<span class="go">   Largest Acknowledged (i),</span>
<span class="go">   ACK Delay (i),</span>
<span class="go">   ACK Range Count (i),</span>
<span class="go">   First ACK Range (i),</span>
<span class="go">   ACK Range (..) ...,</span>
<span class="go">   [ECN Counts (..)],</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<div class="figure" id="id34" style="text-align: center">
<span id="fig-quic-ack-delay"></span><p><img  src="None" alt="Figure made with TikZ" /></p>
<p><span class="caption-number">Fig. 17 </span><span class="caption-text">Utilization of the QUIC ACK delay</span></p>
</div><p>An <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame contains 0 or more <code class="docutils literal notranslate"><span class="pre">ACK</span> <span class="pre">Ranges</span></code>. The format of an <code class="docutils literal notranslate"><span class="pre">ACK</span> <span class="pre">range</span></code> is shown in <a class="reference internal" href="#fig-quic-ack-range"><span class="std std-numref">Listing 8</span></a>. Each range indicates first the number of unacknowledged packets since the smallest acknowledged packet in the preceding range (or the first ACK range). The next field indicates the number of consecutive acknowledged packets.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-ack-range">
<div class="code-block-caption"><span class="caption-number">Listing 8 </span><span class="caption-text">A QUIC ACK range</span><a class="headerlink" href="#fig-quic-ack-range" title="Permalink to this code">¶</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">ACK Range {</span>
<span class="go">   Gap (i),</span>
<span class="go">   ACK Range Length (i),</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>As an example, consider a host that received the following QUIC packets: <code class="docutils literal notranslate"><span class="pre">3,4,6,7,8,9,11,14,16,18</span></code>. To report all the received packets, it will generate the following <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-sample-ack-frame">
<div class="code-block-caption"><span class="caption-number">Listing 9 </span><span class="caption-text">Sample QUIC ACK Frame</span><a class="headerlink" href="#fig-quic-sample-ack-frame" title="Permalink to this code">¶</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">ACK Frame {</span>
<span class="go">   Type (i) = 0x02,</span>
<span class="go">   Largest Acknowledged=18,</span>
<span class="go">   ACK Delay=x,</span>
<span class="go">   ACK Range Count=5,</span>
<span class="go">   First ACK Range=0,</span>
<span class="go">   ACK Range #0 [Gap=2, ACK Range Length=1],</span>
<span class="go">   ACK Range #1 [Gap=2, ACK Range Length=1],</span>
<span class="go">   ACK Range #2 [Gap=3, ACK Range Length=1],</span>
<span class="go">   ACK Range #3 [Gap=2, ACK Range Length=4],</span>
<span class="go">   ACK Range #4 [Gap=2, ACK Range Length=2]</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The QUIC specification recommends to send one <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame after having received two ack-eliciting packets. This corresponds roughly to TCP’s delayed acknowledgments strategy. However, there is ongoing work to allow the sender to provide more guidelines on when and how <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frames should be sent <span id="id21">[<a class="reference internal" href="biblio.html#id8898" title="Jana Iyengar and Ian Swett. QUIC Acknowledgement Frequency. Internet-Draft draft-ietf-quic-ack-frequency-01, Internet Engineering Task Force, October 2021. Work in Progress. URL: https://datatracker.ietf.org/doc/html/draft-ietf-quic-ack-frequency-01.">24</a>]</span>.</p>
<p>It is interesting to observe that since the <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frames are sent inside QUIC packets, they can also be acknowledged. Sending an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> in response to another <code class="docutils literal notranslate"><span class="pre">ACK</span></code> could result in an infinite exchange of <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frames. To prevent this problem, a QUIC sender cannot send an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame in response to a non-eliciting QUIC packet and the <code class="docutils literal notranslate"><span class="pre">ACK</span></code> are one of the non-eliciting frame types. Note that if a receiver that receives many <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frames and thus sends many <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frames wants to obtain information about the reception of its <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame, it can simply send one <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame inside a packet that contains an eliciting frame, e.g. a <code class="docutils literal notranslate"><span class="pre">PING</span></code> frame. This frame will trigger the receiver to acknowledge it and the previously sent <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frames.</p>
<p>In contrast with other reliable transport protocols, QUIC does not use cumulative acknowledgments. As explained earlier, QUIC never retransmits a packet with the same packet number. When a packet is lost, it creates a gap that the receiver reports using an <code class="docutils literal notranslate"><span class="pre">ACK</span> <span class="pre">Range</span></code>. Such a gap will never be filled by retransmissions and obviously should not be reported by the receiver forever. In practice, a receiver will send the acknowledgment that corresponds to a given packet number several times and then will assume that the acknowledgment has been received. A receiver can also rely on other heuristics to determine that a given <code class="docutils literal notranslate"><span class="pre">ACK</span> <span class="pre">Range</span></code> should not be reported anymore. This is the case if the <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame was included in a packet that has been acknowledged by the other peer, but also when the gap was noticed several round-trip times ago.</p>
<p>QUIC also allows a receiver to send information about the ECN flags in the received packets. Two flags of the IP header <span id="id22">[<a class="reference internal" href="biblio.html#id3097" title="K. Ramakrishnan, S. Floyd, and D. Black. The Addition of Explicit Congestion Notification (ECN) to IP. RFC 3168 (Proposed Standard), September 2001. Updated by RFCs 4301, 6040, 8311. URL: https://www.rfc-editor.org/rfc/rfc3168.txt, doi:10.17487/RFC3168.">25</a>]</span> are reserved to indicate support for Explicit Congestion Notification. The QUIC ECN count field shown in <a class="reference internal" href="#fig-quic-ecn-count"><span class="std std-numref">Listing 10</span></a> contains three counters for the different values of the ECN flags. These counters are incremented upon the reception of each QUIC packet based on the values of the ECN flag of the received packet.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-ecn-count">
<div class="code-block-caption"><span class="caption-number">Listing 10 </span><span class="caption-text">A QUIC ECN Count</span><a class="headerlink" href="#fig-quic-ecn-count" title="Permalink to this code">¶</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">ECN Counts {</span>
<span class="go">   ECT0 Count (i),</span>
<span class="go">   ECT1 Count (i),</span>
<span class="go">   ECN-CE Count (i),</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>To fully illustrate the QUIC protocol, let us consider two different QUIC connections. The client starts a QUIC connection with a new server, sends a request, receives a response and then closes the connection. There are no losses in this connection.</p>
<p>Our second example is a followup to this connection. The client now uses 0-RTT to send its request to the server that replies immediately. Unfortunately, one of the packets sent by the server is lost and needs to be retransmitted.</p>
</section>
<section id="migrating-quic-connections">
<h3>Migrating QUIC connections<a class="headerlink" href="#migrating-quic-connections" title="Permalink to this headline">¶</a></h3>
<p>As explained above, QUIC uses connection identifiers. These connection identifiers are used for different purposes. On the server side, they can be used by load-balancers to spread the packets of different connections to different servers. But QUIC ‘s connection identifiers also enable clients to migrate connections from one path to another or even on the same path.</p>
<p>QUIC connection migrations occur in two steps. As an example, we consider the client triggered migrations. These are the most important from a deployment viewpoint. A client can decide to migrate its connection for various reasons,including privacy and performance. A common scenario is a smartphone that moves and goes progressively out of reach of the Wi-Fi access point. When the smartphone notices a decrease in the performance of the Wi-Fi network (lower signal to noise ratio, more losses or retransmissions, …), it can decide to migrate the QUIC connections over the cellular interface. A naive solution would be to simply move the QUIC packets from one interface to another using the same connection identifiers. This is illustrated in <a class="reference internal" href="#fig-quic-naive-migration"><span class="std std-numref">Fig. 18</span></a>.</p>
<div class="figure" id="id35" style="text-align: center">
<span id="fig-quic-naive-migration"></span><p><img  src="None" alt="Figure made with TikZ" /></p>
<p><span class="caption-number">Fig. 18 </span><span class="caption-text">A naive approach to migrate a QUIC connection from Wi-Fi to cellular</span></p>
</div><p>This naive approach has several problems. Consider the server that receives the first QUIC packet from the smartphone’s cellular interface. This packet originates from a different IP address than the previous one, but still belongs to the same connection. If the server accepts this packet and moves the connection to the cellular path, this creates several security risks. First, consider an attacker who has captured a packet over the Wi-Fi network. By sending again this unmodified packet from another IP address, the attacker could disrupt the ongoing connection by forcing the server to send replies to its own IP address. This also opens a risk of denial of service attack as the server could send a large number of packets to the smartphone’s new IP address. QUIC copes with these problems by using different connection identifiers and using the path validation mechanism.</p>
<p>To enable a client to migrate a QUIC connection, the server must first advertise at least one different connection identifier. This is done with the <code class="docutils literal notranslate"><span class="pre">NEW_CONNECTION_ID</span></code> frame. The client uses this additional connection identifier to try to move the connection to a new path. The client cannot use a new path before have the guarantee that the server can reply over the new path. To verify that the new path is bidirectional, the client sends a <code class="docutils literal notranslate"><span class="pre">PATH_CHALLENGE</span></code> frame in a QUIC packet that uses the new connection identifier over the new path. This frame mainly contains a 64 bits random nonce must be echoed by the server. Upon reception of this packet, the server detects an attempt to use a new path with the new connection identifier. It replies with a <code class="docutils literal notranslate"><span class="pre">PATH_RESPONSE</span></code> frame that echoes the client nonce. The server may also perform its own path validation by sending a <code class="docutils literal notranslate"><span class="pre">PATH_CHALLENGE</span></code> with a different nonce in the same packet as the <code class="docutils literal notranslate"><span class="pre">PATH_RESPONSE</span></code>. The client considers that the path has been validated upon reception of the valid <code class="docutils literal notranslate"><span class="pre">PATH_RESPONSE</span></code> frame. The packets that contain the <code class="docutils literal notranslate"><span class="pre">PATH_CHALLENGE</span></code> and <code class="docutils literal notranslate"><span class="pre">PATH_RESPONSE</span></code> frames can be padded with <code class="docutils literal notranslate"><span class="pre">PADDING</span></code> frames. At this time, it switches to the new connection identifier and the new path for all the frames that it sends. It may still continue to receive packets over the former path for some time. The server will switch to the new path once it has received a response to its <code class="docutils literal notranslate"><span class="pre">PATH_CHALLENGE</span></code> if it decided to validate the new path. Otherwise, the reception of a QUICK packet that contains other frames than <code class="docutils literal notranslate"><span class="pre">PATH_CHALLENGE</span></code>, <code class="docutils literal notranslate"><span class="pre">PATH_RESPONSE</span></code>, <code class="docutils literal notranslate"><span class="pre">NEW_CONNECTION_ID</span></code> or <code class="docutils literal notranslate"><span class="pre">PADDING</span></code>. The client could send a <code class="docutils literal notranslate"><span class="pre">NEW_CONNECTION_ID</span></code> frame together with the <code class="docutils literal notranslate"><span class="pre">PATH_CHALLENGE</span></code> frame if the client uses a non-null connection identifier and it has not sent a <code class="docutils literal notranslate"><span class="pre">NEW_CONNECTION_ID</span></code> frame before. This is illustrated in <a class="reference internal" href="#fig-quic-client-migration"><span class="std std-numref">Fig. 19</span></a>.</p>
<div class="figure" id="id36" style="text-align: center">
<span id="fig-quic-client-migration"></span><p><img  src="None" alt="Figure made with TikZ" /></p>
<p><span class="caption-number">Fig. 19 </span><span class="caption-text">A QUIC connection migration initiated by the client</span></p>
</div><p>The examples above showed a connection that migrates from one network interface to another. This is expected to be a frequent situation for smartphones that moves. However, there are also cases where the client will trigger a connection migration even if they use a single network interface. In this case, connection migration allows the client to hide the fact that it has a long QUIC connection with the same endpoint. The initial use case for QUIC is to support HTTP/3, but QUIC could also be used to provide VPN-like services as proposed in <span id="id23">[<a class="reference internal" href="biblio.html#id8896" title="Quentin De Coninck, François Michel, Maxime Piraux, Florentin Rochet, Thomas Given-Wilson, Axel Legay, Olivier Pereira, and Olivier Bonaventure. Pluginizing quic. In Proceedings of the ACM Special Interest Group on Data Communication, pages 59–74. 2019.">26</a>]</span>. By regularly changing their connection identifiers, such VPN services could prevent some middleboxes from blocking them.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unintended QUIC connection migrations</p>
<p>We have described how QUIC clients can trigger connection migrations. There are situations when connection migration occurs without being triggered by the clients. A classical example is when there is a NAT on the path between the client and the server. The QUIC connection has been idle for some time and the NAT has removed the mapping from the client’s private IP address to a public one. When the client sends the next packet over the connection, the NAT creates a new mapping and thus assigns a different IP address to the client. The server receives a packet that uses the same connection identifier but comes from a different IP address than the initial one. This is illustrated in <a class="reference internal" href="#fig-quic-nat-migration"><span class="std std-numref">Fig. 20</span></a>.</p>
<div class="figure" id="id37" style="text-align: center">
<span id="fig-quic-nat-migration"></span><p><img  src="None" alt="Figure made with TikZ" /></p>
<p><span class="caption-number">Fig. 20 </span><span class="caption-text">A QUIC connection migration trigerred by a NAT</span></p>
</div><p>Upon reception of the QUIC packet coming from the new IP address, the server triggers a path validation. Once the path has been validated, the QUIC connection can continue.</p>
</div>
<p>The previous examples have shown that a client can trigger a connection migration to improve performance or for privacy reasons. Our examples have considered that the clients have multiple IP addresses while the servers have a stable IP address. This corresponds to most deployments, but not all of them. Today, many servers are dual-stack. They support both IPv4 and IPv6. When a client starts a QUIC connection over one address family, it could be useful for the client to lean the other server address to be able to switch to this address if the other fails. Another interesting deployments are the server farms where each server has both an anycast address and a unicast one. All servers use the same anycast address and this address is the one advertised using the DNS. When a client initiates a QUIC connection, it targets the anycast address. The Initial QUIC packet is load-balanced to one of the servers of the farm and all subsequent packets of this connection are load-balanced to the same server. In this deployment, all packets must be processed by the load-balancer before reaching the server. When the load is high, the load-balancer could become a bottleneck and it would be useful to allow QUIC connections to migrate to the unicast address of their servers. This unicast address bypasses the load-balancer. The first version of QUIC provides partial support for this bypass by allowing the server to advertise its preferred unicast addresses (IPv4 and IPv6) using the <code class="docutils literal notranslate"><span class="pre">preferred_address</span></code> transport parameter during the handshake. This is illustrated in <a class="reference internal" href="#fig-quic-pref-address"><span class="std std-numref">Fig. 21</span></a>. However, the QUIC specification <span id="id24">[<a class="reference internal" href="biblio.html#id8812" title="J. Iyengar (Ed.) and M. Thomson (Ed.). QUIC: A UDP-Based Multiplexed and Secure Transport. RFC 9000 (Proposed Standard), May 2021. URL: https://www.rfc-editor.org/rfc/rfc9000.txt, doi:10.17487/RFC9000.">8</a>]</span> does not allow the server to force a migration to its preferred address. This migration can only be triggered by the client.</p>
<div class="figure" id="id38" style="text-align: center">
<span id="fig-quic-pref-address"></span><p><img  src="None" alt="Figure made with TikZ" /></p>
<p><span class="caption-number">Fig. 21 </span><span class="caption-text">Using the <code class="docutils literal notranslate"><span class="pre">preferred_address</span></code> transport parameter, a QUIC server can advertise its unicast address</span></p>
</div></section>
<section id="observing-a-quic-connection">
<h3>Observing a QUIC connection<a class="headerlink" href="#observing-a-quic-connection" title="Permalink to this headline">¶</a></h3>
<p>We have now reviewed the main components of the QUIC specification. To illustrate it, let us consider a simple scenario here a client opens a QUIC connection with a server. We leverage Maxime Piraux’s QUIC tracker <span id="id25">[<a class="reference internal" href="biblio.html#id8886" title="Maxime Piraux, Quentin De Coninck, and Olivier Bonaventure. Observing the evolution of quic implementations. In Proceedings of the Workshop on the Evolution, Performance, and Interoperability of QUIC, 8–14. 2018.">27</a>]</span>. In this example, we use the packet trace collected using the <code class="docutils literal notranslate"><span class="pre">nghttp2.org</span></code> server on November 22, 2021 at 18:04:52 CET. This trace is available from <a class="reference external" href="https://quic-tracker.info.ucl.ac.be/traces/20211122/148">https://quic-tracker.info.ucl.ac.be/traces/20211122/148</a>. You can see the contents of the packets, download it as a <code class="docutils literal notranslate"><span class="pre">.pcap</span></code> trace or visualize it using QLog/QViz <span id="id26">[<a class="reference internal" href="biblio.html#id8887" title="Robin Marx, Maxime Piraux, Peter Quax, and Wim Lamotte. Debugging quic and http/3 with qlog and qvis. In Proceedings of the Applied Networking Research Workshop, 58–66. 2020.">28</a>]</span> from this web site.</p>
<p>This trace contains 16 packets. The scenario is a simply handshake with an exchange of data.</p>
<figure class="align-default" id="id39">
<img alt="_images/qtracker-nghttp2-1.png" src="_images/qtracker-nghttp2-1.png" />
<figcaption>
<p><span class="caption-number">Fig. 22 </span><span class="caption-text">Sample quic tracker trace from nghttp2.org</span><a class="headerlink" href="#id39" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>To initiate the connection, the client sends an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> QUIC packet.  It is interesting to analyze the content of this packet. It starts with a long QUIC header shown in <a class="reference internal" href="#fig-trace-quic-header-p1"><span class="std std-numref">Listing 11</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="fig-trace-quic-header-p1">
<div class="code-block-caption"><span class="caption-number">Listing 11 </span><span class="caption-text">The QUIC header of the first packet sent by the client</span><a class="headerlink" href="#fig-trace-quic-header-p1" title="Permalink to this code">¶</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Long Header Packet {</span>
<span class="go">  Header Form (1) = 1,</span>
<span class="go">  Fixed Bit (1) = 1,</span>
<span class="go">  Long Packet Type = 00,</span>
<span class="go">  Type-Specific Bits (4) = 0000,</span>
<span class="go">  Version (32) = 0xff00001d,</span>
<span class="go">  Destination Connection ID Length (8) = 8,</span>
<span class="go">  Destination Connection ID (0..160) = 0x6114ca6ecbe483bb,</span>
<span class="go">  Source Connection ID Length (8) = 8,</span>
<span class="go">  Source Connection ID (0..160) = 0xc9f54d3c298296b9,</span>
<span class="go">  Token Length (i) = 0,</span>
<span class="go">  Length (i) = 1226,</span>
<span class="go">  Packet Number (8..32) = 0,</span>
<span class="go">  Packet Payload (8..) = CRYPTO,</span>
<span class="go">  Type-Specific Payload (..)</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The client proposes a 64 bits connection identifier and uses a random 64 bits identifier for the destination connection identifier. There is no token since this is the first connection from this client to the server. It is useful to note that the packet number of this <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet is set to zero. All QUIC connections start with a packet whose packet number is set to zero in contrast with TCP that uses a random sequence number. The packet contains a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame shown in <a class="reference internal" href="#fig-trace-quic-crypto-p1"><span class="std std-numref">Listing 12</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="fig-trace-quic-crypto-p1">
<div class="code-block-caption"><span class="caption-number">Listing 12 </span><span class="caption-text">The CRYPTO frame of the first QUIC packet sent by the client</span><a class="headerlink" href="#fig-trace-quic-crypto-p1" title="Permalink to this code">¶</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">CRYPTO Frame {</span>
<span class="go">   Type (i) = 0x06,</span>
<span class="go">   Offset (i) = 0,</span>
<span class="go">   Length (i) = 245,</span>
<span class="go">   Crypto Data = ClientHello</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame starts at offset 0 and has a length of <code class="docutils literal notranslate"><span class="pre">245</span></code> bytes. It contains a TLS 1.3 <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> message whose format is specified in <span id="id27">[<a class="reference internal" href="biblio.html#id8271" title="E. Rescorla. The Transport Layer Security (TLS) Protocol Version 1.3. RFC 8446 (Proposed Standard), August 2018. URL: https://www.rfc-editor.org/rfc/rfc8446.txt, doi:10.17487/RFC8446.">6</a>]</span>. This <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> includes a 32 bytes secure random number, a set of proposed cipher suites and a series of TLS extensions. One of these extensions carries the QUIC transport parameters proposed by the client. On this connection, the QUIC tracker client proposed the following ones:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">initial_max_stream_data_bidi_local</span></code> = 0x80004000</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_max_stream_data_uni</span></code> = 0x80004000</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_max_data</span></code> = 0x80008000</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_max_streams_bidi</span></code> = 0x1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_max_streams_uni</span></code> = 0x3</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_idle_timeout</span></code> = 0x6710</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">active_connection_id_limit</span></code> = 0x4</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_packet_size</span></code> = 0x45c0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inital_source_connection_id</span></code> = 0xc9f54d3c298296b9</p></li>
</ul>
</div></blockquote>
<p>Finally, the first QUIC packet contains a <code class="docutils literal notranslate"><span class="pre">PADDING</span></code> frame with 960 dummy bytes. The entire packet is 1236 bytes long.</p>
<p>The server responds to this <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet with two packets. The first one is an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. It starts with the header shown in <a class="reference internal" href="#fig-trace-quic-header-p2"><span class="std std-numref">Listing 13</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="fig-trace-quic-header-p2">
<div class="code-block-caption"><span class="caption-number">Listing 13 </span><span class="caption-text">The QUIC header of the first packet sent by the client</span><a class="headerlink" href="#fig-trace-quic-header-p2" title="Permalink to this code">¶</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Long Header Packet {</span>
<span class="go">  Header Form (1) = 1,</span>
<span class="go">  Fixed Bit (1) = 1,</span>
<span class="go">  Long Packet Type = 10,</span>
<span class="go">  Type-Specific Bits (4) = 0000,</span>
<span class="go">  Version (32) = 0xff00001d,</span>
<span class="go">  Destination Connection ID Length (8) = 8,</span>
<span class="go">  Destination Connection ID (0..160) = 0xc9f54d3c298296b9,</span>
<span class="go">  Source Connection ID Length (8) = 18,</span>
<span class="go">  Source Connection ID (0..160) = 0x8d3470255ae3b0b3fad3c40515132a813dfa,</span>
<span class="go">  Token Length (i) = 0,</span>
<span class="go">  Length (i) = 149,</span>
<span class="go">  Packet Number (8..32) = 0,</span>
<span class="go">  Packet Payload (...)</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>This server uses 18 bytes to encode its connection identifier and proposes the first identifier in the long header. The packet payload contains two frames: an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame and a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame. The <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame (<a class="reference internal" href="#fig-trace-quic-ack-p2"><span class="std std-numref">Listing 14</span></a>) acknowledges the reception of the <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet sent by the client. The <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame contains the TLS ServerHello.</p>
<div class="literal-block-wrapper docutils container" id="fig-trace-quic-ack-p2">
<div class="code-block-caption"><span class="caption-number">Listing 14 </span><span class="caption-text">The ACK Frame of the first packet sent by the server</span><a class="headerlink" href="#fig-trace-quic-ack-p2" title="Permalink to this code">¶</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">ACK Frame {</span>
<span class="go">   Type (i) = 0x02,</span>
<span class="go">   Largest Acknowledged = 0,</span>
<span class="go">   ACK Delay = 0,</span>
<span class="go">   ACK Range Count = 0,</span>
<span class="go">   First ACK Range = 0</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The payload of these <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packets is encrypted using the static key that is derived from the connection identifiers included in the long header.</p>
<p>The server then sends three <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets carrying a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> that contains the <code class="docutils literal notranslate"><span class="pre">TLSEncryptedExtensions</span></code>. These extensions are encrypted using the TLS key. They mainly contain the server certificate. It is interesting to note that the <code class="docutils literal notranslate"><span class="pre">packet_number</span></code> field of the first <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet sent by the server is also set to zero. This is the second, but not the last, packet that we observe with this <code class="docutils literal notranslate"><span class="pre">packet_number</span></code>. QUIC handles packet numbers differently then other protocols. QUIC considers that a QUIC connection is divided in three phases:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The exchange of the <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packets</p></li>
<li><p>The exchange of the <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets</p></li>
<li><p>The exchange of the other packets (<code class="docutils literal notranslate"><span class="pre">0-RTT</span></code>, <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code>, … packets)</p></li>
</ol>
</div></blockquote>
<p>A QUIC host restarts the <code class="docutils literal notranslate"><span class="pre">packet_numer</span></code> at zero in each phase. This explains why it is possible to observe different packets (of different types) with the same <code class="docutils literal notranslate"><span class="pre">packet_number</span></code> over a QUIC connection.</p>
<p>The three <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets sent by the server contain the beginning of the <code class="docutils literal notranslate"><span class="pre">TLSEncryptedExtensions</span></code> sent by the server. To prevent denial of service attacks, the server cannot send more than three full-length packets in response to a packet sent by the client. The server thus needs to wait for an acknowledgment from the client before sending additional packets.</p>
<p>The client sends two different packets to carry these acknowledgments. First, it sends an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet as the sixth packet of the trace. This packet belongs to the packet numbering space of the <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packets. Its packet number is 1 since this is the second <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet sent by the client. The next acknowledgment is carried inside an <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet. It acknowledges the <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets 0-2 sent by the server. Since this is the first <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet sent by the client, its packet number is also 0.</p>
<p>The server then sends the eighth packet that contains the last part of the <code class="docutils literal notranslate"><span class="pre">TLSEncryptedExtensions</span></code> in a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame. By combining the information contained in the <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets and the <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packets, the client can derive the session keys.</p>
<p>The server immediately sends its first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet. This packet contains a short header shown in <a class="reference internal" href="#fig-trace-quic-short-header-p9"><span class="std std-numref">Listing 15</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="fig-trace-quic-short-header-p9">
<div class="code-block-caption"><span class="caption-number">Listing 15 </span><span class="caption-text">The QUIC short header of the first 1-RTT packet sent by the server</span><a class="headerlink" href="#fig-trace-quic-short-header-p9" title="Permalink to this code">¶</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">1-RTT Packet {</span>
<span class="go">   Header Form (1) = 0,</span>
<span class="go">   Fixed Bit (1) = 1,</span>
<span class="go">   Spin Bit (1) = 0,</span>
<span class="go">   Reserved Bits (2)= 00,</span>
<span class="go">   Key Phase (1) = 0,</span>
<span class="go">   Packet Number Length (2)= 0,</span>
<span class="go">   Destination Connection ID = 0xc9f54d3c298296b9,</span>
<span class="go">   Packet Number = 0,</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>This short header contains the connection identifier proposed by the client in the first <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. The payload contains <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frames that create three streams. The client replies with two packets. The tenth packet of the trace is a <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet that carries two frames. The <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame contains the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Finished</span></code> message that finalizes the TLS handshake. The <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame acknowledges the four <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets sent by the server.</p>
<p>The first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet sent by the client contains an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame that acknowledges the <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet sent by the server and flow control information. The client sends a <code class="docutils literal notranslate"><span class="pre">MAX_DATA</span></code> frame to restrict the amount of data that the server can send and one <code class="docutils literal notranslate"><span class="pre">MAX_STREAM</span></code> frame for each of the three streams created by the server.</p>
<p>The twelfth packet of the trace is more interesting. It contains five different frames that are sent by the server. First, the server send two <code class="docutils literal notranslate"><span class="pre">NEW_CONNECTION_ID</span></code> frames that advertise two 18 bytes long connection identifiers which can be used by the client to migrate the connection later. The next frame is the <code class="docutils literal notranslate"><span class="pre">HANDSHAKE_DONE</span></code> that confirms the TLS handshake. The server also sends a <code class="docutils literal notranslate"><span class="pre">NEW_TOKEN</span></code> frame that contains a 57 bytes long token that the client will be able to use in subsequent connections with the server. The last frame is a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame that contains two <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">New</span> <span class="pre">Session</span> <span class="pre">Tickets</span></code>.</p>
<p>It is interesting to analyze how different servers perform the handshake with QUIC tracker. Let us first explore the <a class="reference external" href="https://quic-tracker.info.ucl.ac.be/traces/20211122/140">trace collected with cloudflare-quic.com</a> on the same day. There are several differences with the nghttp2 trace that we analyzed above.</p>
<figure class="align-default" id="id40">
<img alt="_images/qtracker-cloudflare-1.png" src="_images/qtracker-cloudflare-1.png" />
<figcaption>
<p><span class="caption-number">Fig. 23 </span><span class="caption-text">Sample quic tracker trace from cloudflare-quic.com</span><a class="headerlink" href="#id40" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>There are several differences with the first trace that we have analyzed. First, the server sends two small packets in response to the client’s <code class="docutils literal notranslate"><span class="pre">Initial</span></code>. The first packet only contains an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame. It advertises a 20 bytes long connection identifier. The second contains a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame with a the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Hello</span> <span class="pre">Retry</span> <span class="pre">Request</span></code>. This message indicates that the server did not agree with the <code class="docutils literal notranslate"><span class="pre">key_share</span></code> parameter of the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> sent in the first packet. The client acknowledges this packet and sends a new <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> in the fourth packet. The server replies with a <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Server</span> <span class="pre">Hello</span></code> and then the <code class="docutils literal notranslate"><span class="pre">TLSEncryptedExtensions</span></code> in three QUIC packets. The certificate used by <code class="docutils literal notranslate"><span class="pre">cloudflare-quic.com</span></code> is more compact than the one used by <code class="docutils literal notranslate"><span class="pre">nghttp2.org</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packets are also slightly different. The first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet sent by the server contains the <code class="docutils literal notranslate"><span class="pre">HANDSHAKE_DONE</span></code> frame, a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame with two <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">New</span> <span class="pre">Session</span> <span class="pre">Ticket</span></code> messages and a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame that creates one stream. The server then sends two more short packet. Each of these packets contains a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame that creates a new stream. These two short packets could have been packed in the first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet sent by the server. In contrast with <code class="docutils literal notranslate"><span class="pre">nghttp2.org</span></code>, <code class="docutils literal notranslate"><span class="pre">cloudflare-quic.com</span></code> does advertise new connection identifiers.</p>
<p>Our third example is <a class="reference external" href="https://github.com/private-octopus/picoquic">picoquic</a>. The <a class="reference external" href="https://quic-tracker.info.ucl.ac.be/traces/20211122/159">QUIC tracker trace with test.privateoctopus.com</a> contains 13 packets.</p>
<figure class="align-default" id="id41">
<img alt="_images/qtracker-picoquic-1.png" src="_images/qtracker-picoquic-1.png" />
<figcaption>
<p><span class="caption-number">Fig. 24 </span><span class="caption-text">Sample QUIC tracker trace from test.privateoctopus.com</span><a class="headerlink" href="#id41" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>picoquic uses 64 bits long connection identifiers. It manages to fit its <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Encrypted</span> <span class="pre">Extensions</span></code> within two <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets. The first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet that it sends contains a <code class="docutils literal notranslate"><span class="pre">PING</span></code> frame. The second <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet contains one <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame that advertises one <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">New</span> <span class="pre">Session</span> <span class="pre">Ticket</span></code>, three <code class="docutils literal notranslate"><span class="pre">NEW_CONNECTION_ID</span></code> frames and a <code class="docutils literal notranslate"><span class="pre">NEW_TOKEN</span></code>. This test server does not try to create new streams in contrast with the two others.</p>
<p class="rubric">Footnotes</p>
<dl class="footnote brackets">
<dt class="label" id="f-stream-type"><span class="brackets"><a class="fn-backref" href="#id18">1</a></span></dt>
<dd><p>All <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frames have a type that starts with <code class="docutils literal notranslate"><span class="pre">0b0001...</span></code>. The three low order bits of the <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame indicate the presence of the <code class="docutils literal notranslate"><span class="pre">Offset</span></code> and <code class="docutils literal notranslate"><span class="pre">Length</span></code> fields. The lowest order bit is the <code class="docutils literal notranslate"><span class="pre">FIN</span></code> bit.</p>
</dd>
</dl>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Modern Multipath Transport Protocols</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="usecases.html">Use cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="singlepath.html">Single path transport protocols</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">QUIC</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#connection-establishment">Connection establishment</a></li>
<li class="toctree-l2"><a class="reference internal" href="#closing-a-quic-connection">Closing a QUIC connection</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exchanging-data-over-a-quic-connection">Exchanging data over a QUIC connection</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="principles.html">Principles of multipath transport</a></li>
<li class="toctree-l1"><a class="reference internal" href="mptcp.html">Multipath TCP</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpquic.html">Multipath QUIC</a></li>
<li class="toctree-l1"><a class="reference internal" href="sctp.html">SCTP</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementations.html">Multipath TCP implementations</a></li>
<li class="toctree-l1"><a class="reference internal" href="comparison.html">Alternatives</a></li>
<li class="toctree-l1"><a class="reference internal" href="biblio.html">Bibliography</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="singlepath.html" title="previous chapter">Single path transport protocols</a></li>
      <li>Next: <a href="principles.html" title="next chapter">Principles of multipath transport</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Olivier Bonaventure and Quentin De Coninck.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/quic.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>